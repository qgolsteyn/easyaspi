(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["shared"] = factory();
	else
		root["shared"] = factory();
})(global, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/reflect-metadata/Reflect.js":
/*!***************************************************!*\
  !*** ../node_modules/reflect-metadata/Reflect.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*! *****************************************************************************\nCopyright (C) Microsoft. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar Reflect;\n(function (Reflect) {\n    // Metadata Proposal\n    // https://rbuckton.github.io/reflect-metadata/\n    (function (factory) {\n        var root = typeof global === \"object\" ? global :\n            typeof self === \"object\" ? self :\n                typeof this === \"object\" ? this :\n                    Function(\"return this;\")();\n        var exporter = makeExporter(Reflect);\n        if (typeof root.Reflect === \"undefined\") {\n            root.Reflect = Reflect;\n        }\n        else {\n            exporter = makeExporter(root.Reflect, exporter);\n        }\n        factory(exporter);\n        function makeExporter(target, previous) {\n            return function (key, value) {\n                if (typeof target[key] !== \"function\") {\n                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });\n                }\n                if (previous)\n                    previous(key, value);\n            };\n        }\n    })(function (exporter) {\n        var hasOwn = Object.prototype.hasOwnProperty;\n        // feature test for Symbol support\n        var supportsSymbol = typeof Symbol === \"function\";\n        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== \"undefined\" ? Symbol.toPrimitive : \"@@toPrimitive\";\n        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== \"undefined\" ? Symbol.iterator : \"@@iterator\";\n        var supportsCreate = typeof Object.create === \"function\"; // feature test for Object.create support\n        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support\n        var downLevel = !supportsCreate && !supportsProto;\n        var HashMap = {\n            // create an object in dictionary mode (a.k.a. \"slow\" mode in v8)\n            create: supportsCreate\n                ? function () { return MakeDictionary(Object.create(null)); }\n                : supportsProto\n                    ? function () { return MakeDictionary({ __proto__: null }); }\n                    : function () { return MakeDictionary({}); },\n            has: downLevel\n                ? function (map, key) { return hasOwn.call(map, key); }\n                : function (map, key) { return key in map; },\n            get: downLevel\n                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }\n                : function (map, key) { return map[key]; },\n        };\n        // Load global or shim versions of Map, Set, and WeakMap\n        var functionPrototype = Object.getPrototypeOf(Function);\n        var usePolyfill = typeof process === \"object\" && process.env && process.env[\"REFLECT_METADATA_USE_MAP_POLYFILL\"] === \"true\";\n        var _Map = !usePolyfill && typeof Map === \"function\" && typeof Map.prototype.entries === \"function\" ? Map : CreateMapPolyfill();\n        var _Set = !usePolyfill && typeof Set === \"function\" && typeof Set.prototype.entries === \"function\" ? Set : CreateSetPolyfill();\n        var _WeakMap = !usePolyfill && typeof WeakMap === \"function\" ? WeakMap : CreateWeakMapPolyfill();\n        // [[Metadata]] internal slot\n        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots\n        var Metadata = new _WeakMap();\n        /**\n         * Applies a set of decorators to a property of a target object.\n         * @param decorators An array of decorators.\n         * @param target The target object.\n         * @param propertyKey (Optional) The property key to decorate.\n         * @param attributes (Optional) The property descriptor for the target key.\n         * @remarks Decorators are applied in reverse order.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     Example = Reflect.decorate(decoratorsArray, Example);\n         *\n         *     // property (on constructor)\n         *     Reflect.decorate(decoratorsArray, Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     Reflect.decorate(decoratorsArray, Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     Object.defineProperty(Example, \"staticMethod\",\n         *         Reflect.decorate(decoratorsArray, Example, \"staticMethod\",\n         *             Object.getOwnPropertyDescriptor(Example, \"staticMethod\")));\n         *\n         *     // method (on prototype)\n         *     Object.defineProperty(Example.prototype, \"method\",\n         *         Reflect.decorate(decoratorsArray, Example.prototype, \"method\",\n         *             Object.getOwnPropertyDescriptor(Example.prototype, \"method\")));\n         *\n         */\n        function decorate(decorators, target, propertyKey, attributes) {\n            if (!IsUndefined(propertyKey)) {\n                if (!IsArray(decorators))\n                    throw new TypeError();\n                if (!IsObject(target))\n                    throw new TypeError();\n                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))\n                    throw new TypeError();\n                if (IsNull(attributes))\n                    attributes = undefined;\n                propertyKey = ToPropertyKey(propertyKey);\n                return DecorateProperty(decorators, target, propertyKey, attributes);\n            }\n            else {\n                if (!IsArray(decorators))\n                    throw new TypeError();\n                if (!IsConstructor(target))\n                    throw new TypeError();\n                return DecorateConstructor(decorators, target);\n            }\n        }\n        exporter(\"decorate\", decorate);\n        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)\n        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata\n        /**\n         * A default metadata decorator factory that can be used on a class, class member, or parameter.\n         * @param metadataKey The key for the metadata entry.\n         * @param metadataValue The value for the metadata entry.\n         * @returns A decorator function.\n         * @remarks\n         * If `metadataKey` is already defined for the target and target key, the\n         * metadataValue for that key will be overwritten.\n         * @example\n         *\n         *     // constructor\n         *     @Reflect.metadata(key, value)\n         *     class Example {\n         *     }\n         *\n         *     // property (on constructor, TypeScript only)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         static staticProperty;\n         *     }\n         *\n         *     // property (on prototype, TypeScript only)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         property;\n         *     }\n         *\n         *     // method (on constructor)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         static staticMethod() { }\n         *     }\n         *\n         *     // method (on prototype)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         method() { }\n         *     }\n         *\n         */\n        function metadata(metadataKey, metadataValue) {\n            function decorator(target, propertyKey) {\n                if (!IsObject(target))\n                    throw new TypeError();\n                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))\n                    throw new TypeError();\n                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);\n            }\n            return decorator;\n        }\n        exporter(\"metadata\", metadata);\n        /**\n         * Define a unique metadata entry on the target.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param metadataValue A value that contains attached metadata.\n         * @param target The target object on which to define metadata.\n         * @param propertyKey (Optional) The property key for the target.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example);\n         *\n         *     // property (on constructor)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"method\");\n         *\n         *     // decorator factory as metadata-producing annotation.\n         *     function MyAnnotation(options): Decorator {\n         *         return (target, key?) => Reflect.defineMetadata(\"custom:annotation\", options, target, key);\n         *     }\n         *\n         */\n        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);\n        }\n        exporter(\"defineMetadata\", defineMetadata);\n        /**\n         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */\n        function hasMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryHasMetadata(metadataKey, target, propertyKey);\n        }\n        exporter(\"hasMetadata\", hasMetadata);\n        /**\n         * Gets a value indicating whether the target object has the provided metadata key defined.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */\n        function hasOwnMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);\n        }\n        exporter(\"hasOwnMetadata\", hasOwnMetadata);\n        /**\n         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */\n        function getMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryGetMetadata(metadataKey, target, propertyKey);\n        }\n        exporter(\"getMetadata\", getMetadata);\n        /**\n         * Gets the metadata value for the provided metadata key on the target object.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */\n        function getOwnMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);\n        }\n        exporter(\"getOwnMetadata\", getOwnMetadata);\n        /**\n         * Gets the metadata keys defined on the target object or its prototype chain.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns An array of unique metadata keys.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getMetadataKeys(Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getMetadataKeys(Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getMetadataKeys(Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getMetadataKeys(Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getMetadataKeys(Example.prototype, \"method\");\n         *\n         */\n        function getMetadataKeys(target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryMetadataKeys(target, propertyKey);\n        }\n        exporter(\"getMetadataKeys\", getMetadataKeys);\n        /**\n         * Gets the unique metadata keys defined on the target object.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns An array of unique metadata keys.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getOwnMetadataKeys(Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getOwnMetadataKeys(Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getOwnMetadataKeys(Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"method\");\n         *\n         */\n        function getOwnMetadataKeys(target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryOwnMetadataKeys(target, propertyKey);\n        }\n        exporter(\"getOwnMetadataKeys\", getOwnMetadataKeys);\n        /**\n         * Deletes the metadata entry from the target object with the provided key.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns `true` if the metadata entry was found and deleted; otherwise, false.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */\n        function deleteMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);\n            if (IsUndefined(metadataMap))\n                return false;\n            if (!metadataMap.delete(metadataKey))\n                return false;\n            if (metadataMap.size > 0)\n                return true;\n            var targetMetadata = Metadata.get(target);\n            targetMetadata.delete(propertyKey);\n            if (targetMetadata.size > 0)\n                return true;\n            Metadata.delete(target);\n            return true;\n        }\n        exporter(\"deleteMetadata\", deleteMetadata);\n        function DecorateConstructor(decorators, target) {\n            for (var i = decorators.length - 1; i >= 0; --i) {\n                var decorator = decorators[i];\n                var decorated = decorator(target);\n                if (!IsUndefined(decorated) && !IsNull(decorated)) {\n                    if (!IsConstructor(decorated))\n                        throw new TypeError();\n                    target = decorated;\n                }\n            }\n            return target;\n        }\n        function DecorateProperty(decorators, target, propertyKey, descriptor) {\n            for (var i = decorators.length - 1; i >= 0; --i) {\n                var decorator = decorators[i];\n                var decorated = decorator(target, propertyKey, descriptor);\n                if (!IsUndefined(decorated) && !IsNull(decorated)) {\n                    if (!IsObject(decorated))\n                        throw new TypeError();\n                    descriptor = decorated;\n                }\n            }\n            return descriptor;\n        }\n        function GetOrCreateMetadataMap(O, P, Create) {\n            var targetMetadata = Metadata.get(O);\n            if (IsUndefined(targetMetadata)) {\n                if (!Create)\n                    return undefined;\n                targetMetadata = new _Map();\n                Metadata.set(O, targetMetadata);\n            }\n            var metadataMap = targetMetadata.get(P);\n            if (IsUndefined(metadataMap)) {\n                if (!Create)\n                    return undefined;\n                metadataMap = new _Map();\n                targetMetadata.set(P, metadataMap);\n            }\n            return metadataMap;\n        }\n        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata\n        function OrdinaryHasMetadata(MetadataKey, O, P) {\n            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\n            if (hasOwn)\n                return true;\n            var parent = OrdinaryGetPrototypeOf(O);\n            if (!IsNull(parent))\n                return OrdinaryHasMetadata(MetadataKey, parent, P);\n            return false;\n        }\n        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata\n        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {\n            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\n            if (IsUndefined(metadataMap))\n                return false;\n            return ToBoolean(metadataMap.has(MetadataKey));\n        }\n        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata\n        function OrdinaryGetMetadata(MetadataKey, O, P) {\n            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\n            if (hasOwn)\n                return OrdinaryGetOwnMetadata(MetadataKey, O, P);\n            var parent = OrdinaryGetPrototypeOf(O);\n            if (!IsNull(parent))\n                return OrdinaryGetMetadata(MetadataKey, parent, P);\n            return undefined;\n        }\n        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata\n        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {\n            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\n            if (IsUndefined(metadataMap))\n                return undefined;\n            return metadataMap.get(MetadataKey);\n        }\n        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata\n        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {\n            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);\n            metadataMap.set(MetadataKey, MetadataValue);\n        }\n        // 3.1.6.1 OrdinaryMetadataKeys(O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys\n        function OrdinaryMetadataKeys(O, P) {\n            var ownKeys = OrdinaryOwnMetadataKeys(O, P);\n            var parent = OrdinaryGetPrototypeOf(O);\n            if (parent === null)\n                return ownKeys;\n            var parentKeys = OrdinaryMetadataKeys(parent, P);\n            if (parentKeys.length <= 0)\n                return ownKeys;\n            if (ownKeys.length <= 0)\n                return parentKeys;\n            var set = new _Set();\n            var keys = [];\n            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {\n                var key = ownKeys_1[_i];\n                var hasKey = set.has(key);\n                if (!hasKey) {\n                    set.add(key);\n                    keys.push(key);\n                }\n            }\n            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {\n                var key = parentKeys_1[_a];\n                var hasKey = set.has(key);\n                if (!hasKey) {\n                    set.add(key);\n                    keys.push(key);\n                }\n            }\n            return keys;\n        }\n        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys\n        function OrdinaryOwnMetadataKeys(O, P) {\n            var keys = [];\n            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\n            if (IsUndefined(metadataMap))\n                return keys;\n            var keysObj = metadataMap.keys();\n            var iterator = GetIterator(keysObj);\n            var k = 0;\n            while (true) {\n                var next = IteratorStep(iterator);\n                if (!next) {\n                    keys.length = k;\n                    return keys;\n                }\n                var nextValue = IteratorValue(next);\n                try {\n                    keys[k] = nextValue;\n                }\n                catch (e) {\n                    try {\n                        IteratorClose(iterator);\n                    }\n                    finally {\n                        throw e;\n                    }\n                }\n                k++;\n            }\n        }\n        // 6 ECMAScript Data Typ0es and Values\n        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values\n        function Type(x) {\n            if (x === null)\n                return 1 /* Null */;\n            switch (typeof x) {\n                case \"undefined\": return 0 /* Undefined */;\n                case \"boolean\": return 2 /* Boolean */;\n                case \"string\": return 3 /* String */;\n                case \"symbol\": return 4 /* Symbol */;\n                case \"number\": return 5 /* Number */;\n                case \"object\": return x === null ? 1 /* Null */ : 6 /* Object */;\n                default: return 6 /* Object */;\n            }\n        }\n        // 6.1.1 The Undefined Type\n        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type\n        function IsUndefined(x) {\n            return x === undefined;\n        }\n        // 6.1.2 The Null Type\n        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type\n        function IsNull(x) {\n            return x === null;\n        }\n        // 6.1.5 The Symbol Type\n        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type\n        function IsSymbol(x) {\n            return typeof x === \"symbol\";\n        }\n        // 6.1.7 The Object Type\n        // https://tc39.github.io/ecma262/#sec-object-type\n        function IsObject(x) {\n            return typeof x === \"object\" ? x !== null : typeof x === \"function\";\n        }\n        // 7.1 Type Conversion\n        // https://tc39.github.io/ecma262/#sec-type-conversion\n        // 7.1.1 ToPrimitive(input [, PreferredType])\n        // https://tc39.github.io/ecma262/#sec-toprimitive\n        function ToPrimitive(input, PreferredType) {\n            switch (Type(input)) {\n                case 0 /* Undefined */: return input;\n                case 1 /* Null */: return input;\n                case 2 /* Boolean */: return input;\n                case 3 /* String */: return input;\n                case 4 /* Symbol */: return input;\n                case 5 /* Number */: return input;\n            }\n            var hint = PreferredType === 3 /* String */ ? \"string\" : PreferredType === 5 /* Number */ ? \"number\" : \"default\";\n            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);\n            if (exoticToPrim !== undefined) {\n                var result = exoticToPrim.call(input, hint);\n                if (IsObject(result))\n                    throw new TypeError();\n                return result;\n            }\n            return OrdinaryToPrimitive(input, hint === \"default\" ? \"number\" : hint);\n        }\n        // 7.1.1.1 OrdinaryToPrimitive(O, hint)\n        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive\n        function OrdinaryToPrimitive(O, hint) {\n            if (hint === \"string\") {\n                var toString_1 = O.toString;\n                if (IsCallable(toString_1)) {\n                    var result = toString_1.call(O);\n                    if (!IsObject(result))\n                        return result;\n                }\n                var valueOf = O.valueOf;\n                if (IsCallable(valueOf)) {\n                    var result = valueOf.call(O);\n                    if (!IsObject(result))\n                        return result;\n                }\n            }\n            else {\n                var valueOf = O.valueOf;\n                if (IsCallable(valueOf)) {\n                    var result = valueOf.call(O);\n                    if (!IsObject(result))\n                        return result;\n                }\n                var toString_2 = O.toString;\n                if (IsCallable(toString_2)) {\n                    var result = toString_2.call(O);\n                    if (!IsObject(result))\n                        return result;\n                }\n            }\n            throw new TypeError();\n        }\n        // 7.1.2 ToBoolean(argument)\n        // https://tc39.github.io/ecma262/2016/#sec-toboolean\n        function ToBoolean(argument) {\n            return !!argument;\n        }\n        // 7.1.12 ToString(argument)\n        // https://tc39.github.io/ecma262/#sec-tostring\n        function ToString(argument) {\n            return \"\" + argument;\n        }\n        // 7.1.14 ToPropertyKey(argument)\n        // https://tc39.github.io/ecma262/#sec-topropertykey\n        function ToPropertyKey(argument) {\n            var key = ToPrimitive(argument, 3 /* String */);\n            if (IsSymbol(key))\n                return key;\n            return ToString(key);\n        }\n        // 7.2 Testing and Comparison Operations\n        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations\n        // 7.2.2 IsArray(argument)\n        // https://tc39.github.io/ecma262/#sec-isarray\n        function IsArray(argument) {\n            return Array.isArray\n                ? Array.isArray(argument)\n                : argument instanceof Object\n                    ? argument instanceof Array\n                    : Object.prototype.toString.call(argument) === \"[object Array]\";\n        }\n        // 7.2.3 IsCallable(argument)\n        // https://tc39.github.io/ecma262/#sec-iscallable\n        function IsCallable(argument) {\n            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.\n            return typeof argument === \"function\";\n        }\n        // 7.2.4 IsConstructor(argument)\n        // https://tc39.github.io/ecma262/#sec-isconstructor\n        function IsConstructor(argument) {\n            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.\n            return typeof argument === \"function\";\n        }\n        // 7.2.7 IsPropertyKey(argument)\n        // https://tc39.github.io/ecma262/#sec-ispropertykey\n        function IsPropertyKey(argument) {\n            switch (Type(argument)) {\n                case 3 /* String */: return true;\n                case 4 /* Symbol */: return true;\n                default: return false;\n            }\n        }\n        // 7.3 Operations on Objects\n        // https://tc39.github.io/ecma262/#sec-operations-on-objects\n        // 7.3.9 GetMethod(V, P)\n        // https://tc39.github.io/ecma262/#sec-getmethod\n        function GetMethod(V, P) {\n            var func = V[P];\n            if (func === undefined || func === null)\n                return undefined;\n            if (!IsCallable(func))\n                throw new TypeError();\n            return func;\n        }\n        // 7.4 Operations on Iterator Objects\n        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects\n        function GetIterator(obj) {\n            var method = GetMethod(obj, iteratorSymbol);\n            if (!IsCallable(method))\n                throw new TypeError(); // from Call\n            var iterator = method.call(obj);\n            if (!IsObject(iterator))\n                throw new TypeError();\n            return iterator;\n        }\n        // 7.4.4 IteratorValue(iterResult)\n        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue\n        function IteratorValue(iterResult) {\n            return iterResult.value;\n        }\n        // 7.4.5 IteratorStep(iterator)\n        // https://tc39.github.io/ecma262/#sec-iteratorstep\n        function IteratorStep(iterator) {\n            var result = iterator.next();\n            return result.done ? false : result;\n        }\n        // 7.4.6 IteratorClose(iterator, completion)\n        // https://tc39.github.io/ecma262/#sec-iteratorclose\n        function IteratorClose(iterator) {\n            var f = iterator[\"return\"];\n            if (f)\n                f.call(iterator);\n        }\n        // 9.1 Ordinary Object Internal Methods and Internal Slots\n        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots\n        // 9.1.1.1 OrdinaryGetPrototypeOf(O)\n        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof\n        function OrdinaryGetPrototypeOf(O) {\n            var proto = Object.getPrototypeOf(O);\n            if (typeof O !== \"function\" || O === functionPrototype)\n                return proto;\n            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.\n            // Try to determine the superclass constructor. Compatible implementations\n            // must either set __proto__ on a subclass constructor to the superclass constructor,\n            // or ensure each class has a valid `constructor` property on its prototype that\n            // points back to the constructor.\n            // If this is not the same as Function.[[Prototype]], then this is definately inherited.\n            // This is the case when in ES6 or when using __proto__ in a compatible browser.\n            if (proto !== functionPrototype)\n                return proto;\n            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.\n            var prototype = O.prototype;\n            var prototypeProto = prototype && Object.getPrototypeOf(prototype);\n            if (prototypeProto == null || prototypeProto === Object.prototype)\n                return proto;\n            // If the constructor was not a function, then we cannot determine the heritage.\n            var constructor = prototypeProto.constructor;\n            if (typeof constructor !== \"function\")\n                return proto;\n            // If we have some kind of self-reference, then we cannot determine the heritage.\n            if (constructor === O)\n                return proto;\n            // we have a pretty good guess at the heritage.\n            return constructor;\n        }\n        // naive Map shim\n        function CreateMapPolyfill() {\n            var cacheSentinel = {};\n            var arraySentinel = [];\n            var MapIterator = /** @class */ (function () {\n                function MapIterator(keys, values, selector) {\n                    this._index = 0;\n                    this._keys = keys;\n                    this._values = values;\n                    this._selector = selector;\n                }\n                MapIterator.prototype[\"@@iterator\"] = function () { return this; };\n                MapIterator.prototype[iteratorSymbol] = function () { return this; };\n                MapIterator.prototype.next = function () {\n                    var index = this._index;\n                    if (index >= 0 && index < this._keys.length) {\n                        var result = this._selector(this._keys[index], this._values[index]);\n                        if (index + 1 >= this._keys.length) {\n                            this._index = -1;\n                            this._keys = arraySentinel;\n                            this._values = arraySentinel;\n                        }\n                        else {\n                            this._index++;\n                        }\n                        return { value: result, done: false };\n                    }\n                    return { value: undefined, done: true };\n                };\n                MapIterator.prototype.throw = function (error) {\n                    if (this._index >= 0) {\n                        this._index = -1;\n                        this._keys = arraySentinel;\n                        this._values = arraySentinel;\n                    }\n                    throw error;\n                };\n                MapIterator.prototype.return = function (value) {\n                    if (this._index >= 0) {\n                        this._index = -1;\n                        this._keys = arraySentinel;\n                        this._values = arraySentinel;\n                    }\n                    return { value: value, done: true };\n                };\n                return MapIterator;\n            }());\n            return /** @class */ (function () {\n                function Map() {\n                    this._keys = [];\n                    this._values = [];\n                    this._cacheKey = cacheSentinel;\n                    this._cacheIndex = -2;\n                }\n                Object.defineProperty(Map.prototype, \"size\", {\n                    get: function () { return this._keys.length; },\n                    enumerable: true,\n                    configurable: true\n                });\n                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };\n                Map.prototype.get = function (key) {\n                    var index = this._find(key, /*insert*/ false);\n                    return index >= 0 ? this._values[index] : undefined;\n                };\n                Map.prototype.set = function (key, value) {\n                    var index = this._find(key, /*insert*/ true);\n                    this._values[index] = value;\n                    return this;\n                };\n                Map.prototype.delete = function (key) {\n                    var index = this._find(key, /*insert*/ false);\n                    if (index >= 0) {\n                        var size = this._keys.length;\n                        for (var i = index + 1; i < size; i++) {\n                            this._keys[i - 1] = this._keys[i];\n                            this._values[i - 1] = this._values[i];\n                        }\n                        this._keys.length--;\n                        this._values.length--;\n                        if (key === this._cacheKey) {\n                            this._cacheKey = cacheSentinel;\n                            this._cacheIndex = -2;\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n                Map.prototype.clear = function () {\n                    this._keys.length = 0;\n                    this._values.length = 0;\n                    this._cacheKey = cacheSentinel;\n                    this._cacheIndex = -2;\n                };\n                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };\n                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };\n                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };\n                Map.prototype[\"@@iterator\"] = function () { return this.entries(); };\n                Map.prototype[iteratorSymbol] = function () { return this.entries(); };\n                Map.prototype._find = function (key, insert) {\n                    if (this._cacheKey !== key) {\n                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);\n                    }\n                    if (this._cacheIndex < 0 && insert) {\n                        this._cacheIndex = this._keys.length;\n                        this._keys.push(key);\n                        this._values.push(undefined);\n                    }\n                    return this._cacheIndex;\n                };\n                return Map;\n            }());\n            function getKey(key, _) {\n                return key;\n            }\n            function getValue(_, value) {\n                return value;\n            }\n            function getEntry(key, value) {\n                return [key, value];\n            }\n        }\n        // naive Set shim\n        function CreateSetPolyfill() {\n            return /** @class */ (function () {\n                function Set() {\n                    this._map = new _Map();\n                }\n                Object.defineProperty(Set.prototype, \"size\", {\n                    get: function () { return this._map.size; },\n                    enumerable: true,\n                    configurable: true\n                });\n                Set.prototype.has = function (value) { return this._map.has(value); };\n                Set.prototype.add = function (value) { return this._map.set(value, value), this; };\n                Set.prototype.delete = function (value) { return this._map.delete(value); };\n                Set.prototype.clear = function () { this._map.clear(); };\n                Set.prototype.keys = function () { return this._map.keys(); };\n                Set.prototype.values = function () { return this._map.values(); };\n                Set.prototype.entries = function () { return this._map.entries(); };\n                Set.prototype[\"@@iterator\"] = function () { return this.keys(); };\n                Set.prototype[iteratorSymbol] = function () { return this.keys(); };\n                return Set;\n            }());\n        }\n        // naive WeakMap shim\n        function CreateWeakMapPolyfill() {\n            var UUID_SIZE = 16;\n            var keys = HashMap.create();\n            var rootKey = CreateUniqueKey();\n            return /** @class */ (function () {\n                function WeakMap() {\n                    this._key = CreateUniqueKey();\n                }\n                WeakMap.prototype.has = function (target) {\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);\n                    return table !== undefined ? HashMap.has(table, this._key) : false;\n                };\n                WeakMap.prototype.get = function (target) {\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);\n                    return table !== undefined ? HashMap.get(table, this._key) : undefined;\n                };\n                WeakMap.prototype.set = function (target, value) {\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);\n                    table[this._key] = value;\n                    return this;\n                };\n                WeakMap.prototype.delete = function (target) {\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);\n                    return table !== undefined ? delete table[this._key] : false;\n                };\n                WeakMap.prototype.clear = function () {\n                    // NOTE: not a real clear, just makes the previous data unreachable\n                    this._key = CreateUniqueKey();\n                };\n                return WeakMap;\n            }());\n            function CreateUniqueKey() {\n                var key;\n                do\n                    key = \"@@WeakMap@@\" + CreateUUID();\n                while (HashMap.has(keys, key));\n                keys[key] = true;\n                return key;\n            }\n            function GetOrCreateWeakMapTable(target, create) {\n                if (!hasOwn.call(target, rootKey)) {\n                    if (!create)\n                        return undefined;\n                    Object.defineProperty(target, rootKey, { value: HashMap.create() });\n                }\n                return target[rootKey];\n            }\n            function FillRandomBytes(buffer, size) {\n                for (var i = 0; i < size; ++i)\n                    buffer[i] = Math.random() * 0xff | 0;\n                return buffer;\n            }\n            function GenRandomBytes(size) {\n                if (typeof Uint8Array === \"function\") {\n                    if (typeof crypto !== \"undefined\")\n                        return crypto.getRandomValues(new Uint8Array(size));\n                    if (typeof msCrypto !== \"undefined\")\n                        return msCrypto.getRandomValues(new Uint8Array(size));\n                    return FillRandomBytes(new Uint8Array(size), size);\n                }\n                return FillRandomBytes(new Array(size), size);\n            }\n            function CreateUUID() {\n                var data = GenRandomBytes(UUID_SIZE);\n                // mark as random - RFC 4122 § 4.4\n                data[6] = data[6] & 0x4f | 0x40;\n                data[8] = data[8] & 0xbf | 0x80;\n                var result = \"\";\n                for (var offset = 0; offset < UUID_SIZE; ++offset) {\n                    var byte = data[offset];\n                    if (offset === 4 || offset === 6 || offset === 8)\n                        result += \"-\";\n                    if (byte < 16)\n                        result += \"0\";\n                    result += byte.toString(16).toLowerCase();\n                }\n                return result;\n            }\n        }\n        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.\n        function MakeDictionary(obj) {\n            obj.__ = undefined;\n            delete obj.__;\n            return obj;\n        }\n    });\n})(Reflect || (Reflect = {}));\n\n\n//# sourceURL=webpack://shared/../node_modules/reflect-metadata/Reflect.js?");

/***/ }),

/***/ "../node_modules/typedjson/js/typedjson.js":
/*!*************************************************!*\
  !*** ../node_modules/typedjson/js/typedjson.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// [typedjson]  Version: 1.5.0 - 2019-10-13  \n (function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/typedjson/helpers.ts\nvar METADATA_FIELD_KEY = \"__typedJsonJsonObjectMetadataInformation__\";\nfunction getDefaultValue(type) {\n    switch (type) {\n        case Number:\n            return 0;\n        case String:\n            return \"\";\n        case Boolean:\n            return false;\n        case Array:\n            return [];\n        default:\n            return undefined;\n    }\n}\n/**\n * Determines whether the specified type is a type that can be passed on \"as-is\" into `JSON.stringify`.\n * Values of these types don't need special conversion.\n * @param type The constructor of the type (wrapper constructor for primitive types, e.g. `Number` for `number`).\n */\nfunction isDirectlySerializableNativeType(type) {\n    return !!(~[Date, Number, String, Boolean].indexOf(type));\n}\nfunction isTypeTypedArray(type) {\n    return !!(~[Float32Array, Float64Array, Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array]\n        .indexOf(type));\n}\nfunction isPrimitiveValue(obj) {\n    switch (typeof obj) {\n        case \"string\":\n        case \"number\":\n        case \"boolean\":\n            return true;\n        default:\n            return (obj instanceof String || obj instanceof Number || obj instanceof Boolean);\n    }\n}\nfunction isObject(value) {\n    return typeof value === \"object\";\n}\nfunction shouldOmitParseString(jsonStr, expectedType) {\n    var expectsTypesSerializedAsStrings = expectedType === String\n        || expectedType === ArrayBuffer\n        || expectedType === DataView;\n    var hasQuotes = jsonStr.length >= 2 && jsonStr[0] === '\"' && jsonStr[jsonStr.length - 1] === '\"';\n    var isInteger = /^\\d+$/.test(jsonStr.trim());\n    return (expectsTypesSerializedAsStrings && !hasQuotes) || ((!hasQuotes && !isInteger) && expectedType === Date);\n}\nfunction parseToJSObject(json, expectedType) {\n    if (typeof json !== 'string' || shouldOmitParseString(json, expectedType)) {\n        return json;\n    }\n    return JSON.parse(json);\n}\n/**\n * Determines if 'A' is a sub-type of 'B' (or if 'A' equals 'B').\n * @param A The supposed derived type.\n * @param B The supposed base type.\n */\nfunction isSubtypeOf(A, B) {\n    return A === B || A.prototype instanceof B;\n}\nfunction logError(message) {\n    var optionalParams = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        optionalParams[_i - 1] = arguments[_i];\n    }\n    if (typeof console === \"object\" && typeof console.error === \"function\") {\n        console.error.apply(console, [message].concat(optionalParams));\n    }\n    else if (typeof console === \"object\" && typeof console.log === \"function\") {\n        console.log.apply(console, [\"ERROR: \" + message].concat(optionalParams));\n    }\n}\nfunction logMessage(message) {\n    var optionalParams = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        optionalParams[_i - 1] = arguments[_i];\n    }\n    if (typeof console === \"object\" && typeof console.log === \"function\") {\n        console.log.apply(console, [message].concat(optionalParams));\n    }\n}\nfunction logWarning(message) {\n    var optionalParams = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        optionalParams[_i - 1] = arguments[_i];\n    }\n    if (typeof console === \"object\" && typeof console.warn === \"function\") {\n        console.warn.apply(console, [message].concat(optionalParams));\n    }\n    else if (typeof console === \"object\" && typeof console.log === \"function\") {\n        console.log.apply(console, [\"WARNING: \" + message].concat(optionalParams));\n    }\n}\n/**\n * Checks if the value is considered defined (not undefined and not null).\n * @param value\n */\nfunction isValueDefined(value) {\n    return !(typeof value === \"undefined\" || value === null);\n}\nfunction isInstanceOf(value, constructor) {\n    if (typeof value === \"number\") {\n        return (constructor === Number);\n    }\n    else if (typeof value === \"string\") {\n        return (constructor === String);\n    }\n    else if (typeof value === \"boolean\") {\n        return (constructor === Boolean);\n    }\n    else if (isObject(value)) {\n        return (value instanceof constructor);\n    }\n    return false;\n}\nvar isReflectMetadataSupported = (typeof Reflect === \"object\" && typeof Reflect.getMetadata === \"function\");\n/**\n * Gets the name of a function.\n * @param fn The function whose name to get.\n */\nfunction nameof(fn) {\n    if (typeof fn.name === \"string\") {\n        return fn.name;\n    }\n    else {\n        return \"undefined\";\n    }\n}\n\n// CONCATENATED MODULE: ./src/typedjson/metadata.ts\n\nvar metadata_JsonObjectMetadata = /** @class */ (function () {\n    //#endregion\n    function JsonObjectMetadata(classType) {\n        this.dataMembers = new Map();\n        this.knownTypes = new Set();\n        /**\n         * Indicates whether this class was explicitly annotated with @jsonObject\n         * or implicitly by @jsonMember\n         */\n        this.isExplicitlyMarked = false;\n        /**\n         * Indicates whether this type is handled without annotation. This is usually\n         * used for the builtin types (except for Maps, Sets, and normal Arrays).\n         */\n        this.isHandledWithoutAnnotation = false;\n        this.classType = classType;\n    }\n    //#region Static\n    /**\n     * Gets the name of a class as it appears in a serialized JSON string.\n     * @param ctor The constructor of a class (with or without jsonObject).\n     */\n    JsonObjectMetadata.getJsonObjectName = function (ctor) {\n        var metadata = JsonObjectMetadata.getFromConstructor(ctor);\n        return metadata ? nameof(metadata.classType) : nameof(ctor);\n    };\n    /**\n     * Gets jsonObject metadata information from a class.\n     * @param ctor The constructor class.\n     */\n    JsonObjectMetadata.getFromConstructor = function (ctor) {\n        var prototype = ctor.prototype;\n        if (!prototype) {\n            return;\n        }\n        var metadata;\n        if (prototype.hasOwnProperty(METADATA_FIELD_KEY)) {\n            // The class prototype contains own jsonObject metadata\n            metadata = prototype[METADATA_FIELD_KEY];\n        }\n        // Ignore implicitly added jsonObject (through jsonMember)\n        if (metadata && metadata.isExplicitlyMarked) {\n            return metadata;\n        }\n        // In the end maybe it is something which we can handle directly\n        if (JsonObjectMetadata.doesHandleWithoutAnnotation(ctor)) {\n            var primitiveMeta = new JsonObjectMetadata(ctor);\n            primitiveMeta.isExplicitlyMarked = true;\n            // we do not store the metadata here to not modify builtin prototype\n            return primitiveMeta;\n        }\n    };\n    /**\n     * Gets the known type name of a jsonObject class for type hint.\n     * @param constructor The constructor class.\n     */\n    JsonObjectMetadata.getKnownTypeNameFromType = function (constructor) {\n        var metadata = JsonObjectMetadata.getFromConstructor(constructor);\n        return metadata ? nameof(metadata.classType) : nameof(constructor);\n    };\n    JsonObjectMetadata.doesHandleWithoutAnnotation = function (ctor) {\n        return isDirectlySerializableNativeType(ctor) || isTypeTypedArray(ctor)\n            || ctor === DataView || ctor === ArrayBuffer;\n    };\n    return JsonObjectMetadata;\n}());\n\nfunction injectMetadataInformation(constructor, propKey, metadata) {\n    var decoratorName = \"@jsonMember on \" + nameof(constructor.constructor) + \".\" + String(propKey); // For error messages.\n    var objectMetadata;\n    // When a property decorator is applied to a static member, 'constructor' is a constructor function.\n    // See: https://github.com/Microsoft/TypeScript-Handbook/blob/master/pages/Decorators.md#property-decorators\n    // ... and static members are not supported here, so abort.\n    if (typeof constructor === \"function\") {\n        logError(decoratorName + \": cannot use a static property.\");\n        return;\n    }\n    // Methods cannot be serialized.\n    // @ts-ignore symbol indexing is not supported by ts\n    if (typeof constructor[propKey] === \"function\") {\n        logError(decoratorName + \": cannot use a method property.\");\n        return;\n    }\n    if (!metadata || (!metadata.ctor && !metadata.deserializer)) {\n        logError(decoratorName + \": JsonMemberMetadata has unknown ctor.\");\n        return;\n    }\n    // Add jsonObject metadata to 'constructor' if not yet exists ('constructor' is the prototype).\n    // NOTE: this will not fire up custom serialization, as 'constructor' must be explicitly marked with '@jsonObject' as well.\n    if (!constructor.hasOwnProperty(METADATA_FIELD_KEY)) {\n        // No *own* metadata, create new.\n        objectMetadata = new metadata_JsonObjectMetadata(constructor.constructor);\n        // Inherit @JsonMembers from parent @jsonObject (if any).\n        var parentMetadata = constructor[METADATA_FIELD_KEY];\n        if (parentMetadata) // && !constructor.hasOwnProperty(Helpers.METADATA_FIELD_KEY)\n         {\n            parentMetadata.dataMembers.forEach(function (_metadata, _propKey) { return objectMetadata.dataMembers.set(_propKey, _metadata); });\n        }\n        // ('constructor' is the prototype of the involved class, metadata information is added to this class prototype).\n        Object.defineProperty(constructor, METADATA_FIELD_KEY, {\n            enumerable: false,\n            configurable: false,\n            writable: false,\n            value: objectMetadata\n        });\n    }\n    else {\n        // JsonObjectMetadata already exists on 'constructor'.\n        objectMetadata = constructor[METADATA_FIELD_KEY];\n    }\n    if (!metadata.deserializer) {\n        // @ts-ignore above is a check (!deser && !ctor)\n        objectMetadata.knownTypes.add(metadata.ctor);\n    }\n    if (metadata.keyType)\n        objectMetadata.knownTypes.add(metadata.keyType);\n    if (metadata.elementType)\n        metadata.elementType.forEach(function (elemCtor) { return objectMetadata.knownTypes.add(elemCtor); });\n    // clear metadata of undefined properties to save memory\n    Object.keys(metadata)\n        .forEach(function (key) { return (metadata[key] === undefined) && delete metadata[key]; });\n    objectMetadata.dataMembers.set(metadata.name, metadata);\n}\n\n// CONCATENATED MODULE: ./src/typedjson/options-base.ts\n/**\n * This options cascade through the annotations. Options set\n * in the more specific place override the previous option.\n * Ex. @jsonMember overrides TypedJson options.\n */\nvar kAllOptions = [\n    'preserveNull',\n];\nfunction extractOptionBase(from) {\n    var options = Object.keys(from)\n        .filter(function (key) { return kAllOptions.includes(key); })\n        .reduce(function (obj, key) {\n        obj[key] = from[key];\n        return obj;\n    }, {});\n    return Object.keys(options).length > 0 ? options : undefined;\n}\nfunction getDefaultOptionOf(key) {\n    switch (key) {\n        case \"preserveNull\":\n            return false;\n    }\n    // never reached\n    return null;\n}\nfunction getOptionValue(key, options) {\n    if (options && options[key] != null)\n        return options[key];\n    return getDefaultOptionOf(key);\n}\nfunction mergeOptions(existing, moreSpecific) {\n    return !moreSpecific\n        ? existing\n        : Object.assign({}, existing, moreSpecific);\n}\n\n// CONCATENATED MODULE: ./src/typedjson/serializer.ts\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n\n\nfunction isArrayTypeInfo(typeInfo) {\n    return typeInfo.selfType === Array;\n}\nfunction isSetTypeInfo(typeInfo) {\n    return typeInfo.selfType === Set;\n}\nfunction isMapTypeInfo(typeInfo) {\n    return typeInfo.selfType === Map;\n}\n/**\n * Utility class, converts a typed object tree (i.e. a tree of class instances, arrays of class instances, and so on) to an untyped javascript object (also\n * called \"simple javascript object\"), and emits any necessary type hints in the process (for polymorphism).\n *\n * The converted object tree is what will be given to `JSON.stringify` to convert to string as the last step, the serialization is basically like:\n *\n * (1) typed object-tree -> (2) simple JS object-tree -> (3) JSON-string\n */\nvar serializer_Serializer = /** @class */ (function () {\n    function Serializer() {\n        this._typeHintEmitter = function (targetObject, sourceObject, expectedSourceType, sourceTypeMetadata) {\n            // By default, we put a \"__type\" property on the output object if the actual object is not the same as the expected one, so that deserialization\n            // will know what to deserialize into (given the required known-types are defined, and the object is a valid subtype of the expected type).\n            if (sourceObject.constructor !== expectedSourceType) {\n                var name_1 = sourceTypeMetadata && sourceTypeMetadata.name\n                    ? sourceTypeMetadata.name\n                    : nameof(sourceObject.constructor);\n                // TODO: Perhaps this can work correctly without string-literal access?\n                // tslint:disable-next-line:no-string-literal\n                targetObject[\"__type\"] = name_1;\n            }\n        };\n        this._errorHandler = function (error) { return logError(error); };\n    }\n    Serializer.prototype.setTypeHintEmitter = function (typeEmitterCallback) {\n        if (typeof typeEmitterCallback !== \"function\") {\n            throw new TypeError(\"'typeEmitterCallback' is not a function.\");\n        }\n        this._typeHintEmitter = typeEmitterCallback;\n    };\n    Serializer.prototype.setErrorHandler = function (errorHandlerCallback) {\n        if (typeof errorHandlerCallback !== \"function\") {\n            throw new TypeError(\"'errorHandlerCallback' is not a function.\");\n        }\n        this._errorHandler = errorHandlerCallback;\n    };\n    /**\n     * Convert a value of any supported serializable type.\n     * The value type will be detected, and the correct serialization method will be called.\n     */\n    Serializer.prototype.convertSingleValue = function (sourceObject, typeInfo, memberName, memberOptions) {\n        if (memberName === void 0) { memberName = \"object\"; }\n        if (this.retrievePreserveNull(memberOptions) && sourceObject === null)\n            return null;\n        if (!isValueDefined(sourceObject))\n            return;\n        if (!isInstanceOf(sourceObject, typeInfo.selfType)) {\n            var expectedName = nameof(typeInfo.selfType);\n            var actualName = nameof(sourceObject.constructor);\n            this._errorHandler(new TypeError(\"Could not serialize '\" + memberName + \"': expected '\" + expectedName + \"', got '\" + actualName + \"'.\"));\n            return;\n        }\n        if (isDirectlySerializableNativeType(typeInfo.selfType)) {\n            return sourceObject;\n        }\n        else if (typeInfo.selfType === ArrayBuffer) {\n            return this.convertAsArrayBuffer(sourceObject);\n        }\n        else if (typeInfo.selfType === DataView) {\n            return this.convertAsDataView(sourceObject);\n        }\n        else if (isArrayTypeInfo(typeInfo)) {\n            return this.convertAsArray(sourceObject, typeInfo.elementTypes, memberName, memberOptions);\n        }\n        else if (isSetTypeInfo(typeInfo)) {\n            return this.convertAsSet(sourceObject, typeInfo.elementTypes[0], memberName, memberOptions);\n        }\n        else if (isMapTypeInfo(typeInfo)) {\n            return this.convertAsMap(sourceObject, typeInfo.keyType, typeInfo.elementTypes[0], memberName, memberOptions);\n        }\n        else if (isTypeTypedArray(typeInfo.selfType)) {\n            return this.convertAsTypedArray(sourceObject);\n        }\n        else if (typeof sourceObject === \"object\") {\n            return this.convertAsObject(sourceObject, typeInfo, memberName, memberOptions);\n        }\n    };\n    /**\n     * Performs the conversion of a typed object (usually a class instance) to a simple\n     * javascript object for serialization.\n     */\n    Serializer.prototype.convertAsObject = function (sourceObject, typeInfo, memberName, memberOptions) {\n        var _this = this;\n        var sourceTypeMetadata;\n        var targetObject;\n        if (sourceObject.constructor !== typeInfo.selfType && sourceObject instanceof typeInfo.selfType) {\n            // The source object is not of the expected type, but it is a valid subtype.\n            // This is OK, and we'll proceed to gather object metadata from the subtype instead.\n            sourceTypeMetadata = metadata_JsonObjectMetadata.getFromConstructor(sourceObject.constructor);\n        }\n        else {\n            sourceTypeMetadata = metadata_JsonObjectMetadata.getFromConstructor(typeInfo.selfType);\n        }\n        if (sourceTypeMetadata) {\n            if (sourceTypeMetadata.beforeSerializationMethodName) {\n                // check for member first\n                if (typeof sourceObject[sourceTypeMetadata.beforeSerializationMethodName] === \"function\") {\n                    sourceObject[sourceTypeMetadata.beforeSerializationMethodName]();\n                }\n                // check for static\n                else if (typeof sourceObject.constructor[sourceTypeMetadata.beforeSerializationMethodName] === \"function\") {\n                    sourceObject.constructor[sourceTypeMetadata.beforeSerializationMethodName]();\n                }\n                else {\n                    this._errorHandler(new TypeError(\"beforeSerialization callback '\" + nameof(sourceTypeMetadata.classType) + \".\" + sourceTypeMetadata.beforeSerializationMethodName + \"' is not a method.\"));\n                }\n            }\n            var sourceMeta_1 = sourceTypeMetadata;\n            // Strong-typed serialization available.\n            // We'll serialize by members that have been marked with @jsonMember (including array/set/map members),\n            // and perform recursive conversion on each of them. The converted objects are put on the 'targetObject',\n            // which is what will be put into 'JSON.stringify' finally.\n            targetObject = {};\n            var classOptions_1 = mergeOptions(this.options, sourceMeta_1.options);\n            sourceMeta_1.dataMembers.forEach(function (memberMetadata) {\n                var memberOptions = mergeOptions(classOptions_1, memberMetadata.options);\n                var serialized;\n                if (memberMetadata.serializer) {\n                    serialized = memberMetadata.serializer(sourceObject[memberMetadata.key]);\n                }\n                else if (memberMetadata.ctor) {\n                    serialized = _this.convertSingleValue(sourceObject[memberMetadata.key], {\n                        selfType: memberMetadata.ctor,\n                        elementTypes: memberMetadata.elementType,\n                        keyType: memberMetadata.keyType,\n                    }, nameof(sourceMeta_1.classType) + \".\" + memberMetadata.key, memberOptions);\n                }\n                else {\n                    throw new TypeError(\"Could not serialize \" + memberMetadata.name + \", there is\"\n                        + \" no constructor nor serialization function to use.\");\n                }\n                if (isValueDefined(serialized)\n                    || (_this.retrievePreserveNull(memberOptions) && serialized === null)) {\n                    targetObject[memberMetadata.name] = serialized;\n                }\n            });\n        }\n        else {\n            // Untyped serialization, \"as-is\", we'll just pass the object on.\n            // We'll clone the source object, because type hints are added to the object itself, and we don't want to modify to the original object.\n            targetObject = __assign({}, sourceObject);\n        }\n        // Add type-hint.\n        this._typeHintEmitter(targetObject, sourceObject, typeInfo.selfType, sourceTypeMetadata);\n        return targetObject;\n    };\n    /**\n     * Performs the conversion of an array of typed objects (or primitive values) to an array of simple javascript objects (or primitive values) for\n     * serialization.\n     * @param expectedElementType The expected type of elements. If the array is supposed to be multi-dimensional, subsequent elements define lower dimensions.\n     * @param memberName Name of the object being serialized, used for debugging purposes.\n     * @param memberOptions If converted as a member, the member options.\n     */\n    Serializer.prototype.convertAsArray = function (sourceObject, expectedElementType, memberName, memberOptions) {\n        var _this = this;\n        if (memberName === void 0) { memberName = \"object\"; }\n        if (expectedElementType.length === 0 || !expectedElementType[0])\n            throw new TypeError(\"Could not serialize \" + memberName + \" as Array: missing element type definition.\");\n        // Check the type of each element, individually.\n        // If at least one array element type is incorrect, we return undefined, which results in no\n        // value emitted during serialization. This is so that invalid element types don't unexpectedly\n        // alter the ordering of other, valid elements, and that no unexpected undefined values are in\n        // the emitted array.\n        sourceObject.forEach(function (element, i) {\n            if (!(_this.retrievePreserveNull(memberOptions) && element === null)\n                && !isInstanceOf(element, expectedElementType[0])) {\n                var expectedTypeName = nameof(expectedElementType[0]);\n                var actualTypeName = element && nameof(element.constructor);\n                throw new TypeError(\"Could not serialize \" + memberName + \"[\" + i + \"]:\" +\n                    (\" expected '\" + expectedTypeName + \"', got '\" + actualTypeName + \"'.\"));\n            }\n        });\n        var typeInfoForElements = {\n            selfType: expectedElementType[0],\n            // For multidimensional arrays.\n            elementTypes: expectedElementType.length > 1 ? expectedElementType.slice(1) : [],\n        };\n        if (memberName) {\n            // Just for debugging purposes.\n            memberName += \"[]\";\n        }\n        return sourceObject.map(function (element) { return _this.convertSingleValue(element, typeInfoForElements, memberName, memberOptions); });\n    };\n    /**\n     * Performs the conversion of a set of typed objects (or primitive values) into an array\n     * of simple javascript objects.\n     *\n     * @param sourceObject\n     * @param expectedElementType The constructor of the expected Set elements\n     *        (e.g. `Number` for `Set<number>`, or `MyClass` for `Set<MyClass>`).\n     * @param memberName Name of the object being serialized, used for debugging purposes.\n     * @param memberOptions If converted as a member, the member options.\n     * @returns\n     */\n    Serializer.prototype.convertAsSet = function (sourceObject, expectedElementType, memberName, memberOptions) {\n        var _this = this;\n        if (memberName === void 0) { memberName = \"object\"; }\n        if (!expectedElementType)\n            throw new TypeError(\"Could not serialize \" + memberName + \" as Set: missing element type definition.\");\n        var elementTypeInfo = {\n            selfType: expectedElementType,\n        };\n        // For debugging and error tracking.\n        if (memberName)\n            memberName += \"[]\";\n        var resultArray = [];\n        // Convert each element of the set, and put it into an output array.\n        // The output array is the one serialized, as JSON.stringify does not support Set serialization.\n        // (TODO: clarification needed)\n        sourceObject.forEach(function (element) {\n            var resultElement = _this.convertSingleValue(element, elementTypeInfo, memberName, memberOptions);\n            // Add to output if the source element was undefined, OR the converted element is defined.\n            // This will add intentionally undefined values to output, but not values that became undefined\n            // DURING serializing (usually because of a type-error).\n            if (!isValueDefined(element) || isValueDefined(resultElement)) {\n                resultArray.push(resultElement);\n            }\n        });\n        return resultArray;\n    };\n    /**\n     * Performs the conversion of a map of typed objects (or primitive values) into an array\n     * of simple javascript objects with `key` and `value` properties.\n     *\n     * @param sourceObject\n     * @param expectedKeyType The constructor of the expected Map keys\n     *        (e.g. `Number` for `Map<number, any>`, or `MyClass` for `Map<MyClass, any>`).\n     * @param expectedElementType The constructor of the expected Map values\n     *        (e.g. `Number` for `Map<any, number>`, or `MyClass` for `Map<any, MyClass>`).\n     * @param memberName Name of the object being serialized, used for debugging purposes.\n     * @param memberOptions If converted as a member, the member options.\n     */\n    Serializer.prototype.convertAsMap = function (sourceObject, expectedKeyType, expectedElementType, memberName, memberOptions) {\n        var _this = this;\n        if (memberName === void 0) { memberName = \"object\"; }\n        if (!expectedElementType)\n            throw new TypeError(\"Could not serialize \" + memberName + \" as Map: missing value type definition.\");\n        if (!expectedKeyType)\n            throw new TypeError(\"Could not serialize \" + memberName + \" as Map: missing key type definition.\");\n        var elementTypeInfo = {\n            selfType: expectedElementType,\n            elementTypes: [expectedElementType]\n        };\n        var keyTypeInfo = {\n            selfType: expectedKeyType\n        };\n        if (memberName)\n            memberName += \"[]\";\n        var resultArray = [];\n        var preserveNull = this.retrievePreserveNull(memberOptions);\n        // Convert each *entry* in the map to a simple javascript object with key and value properties.\n        sourceObject.forEach(function (value, key) {\n            var resultKeyValuePairObj = {\n                key: _this.convertSingleValue(key, keyTypeInfo, memberName, memberOptions),\n                value: _this.convertSingleValue(value, elementTypeInfo, memberName, memberOptions),\n            };\n            // We are not going to emit entries with undefined keys OR undefined values.\n            var keyDefined = isValueDefined(resultKeyValuePairObj.key);\n            var valueDefined = isValueDefined(resultKeyValuePairObj.value)\n                || (resultKeyValuePairObj.value === null && preserveNull);\n            if (keyDefined && valueDefined) {\n                resultArray.push(resultKeyValuePairObj);\n            }\n        });\n        return resultArray;\n    };\n    /**\n     * Performs the conversion of a typed javascript array to a simple untyped javascript array.\n     * This is needed because typed arrays are otherwise serialized as objects, so we'll end up\n     * with something like \"{ 0: 0, 1: 1, ... }\".\n     *\n     * @param sourceObject\n     * @returns\n     */\n    Serializer.prototype.convertAsTypedArray = function (sourceObject) {\n        return Array.from(sourceObject);\n    };\n    /**\n     * Performs the conversion of a raw ArrayBuffer to a string.\n     */\n    Serializer.prototype.convertAsArrayBuffer = function (buffer) {\n        // ArrayBuffer -> 16-bit character codes -> character array -> joined string.\n        return Array.from(new Uint16Array(buffer)).map(function (charCode) { return String.fromCharCode(charCode); }).join(\"\");\n    };\n    /**\n     * Performs the conversion of DataView, converting its internal ArrayBuffer to a string and\n     * returning that string.\n     */\n    Serializer.prototype.convertAsDataView = function (dataView) {\n        return this.convertAsArrayBuffer(dataView.buffer);\n    };\n    Serializer.prototype.retrievePreserveNull = function (memberOptions) {\n        return getOptionValue('preserveNull', mergeOptions(this.options, memberOptions));\n    };\n    return Serializer;\n}());\n\n\n// CONCATENATED MODULE: ./src/typedjson/deserializer.ts\n\n\n\n/**\n * Utility class, converts a simple/untyped javascript object-tree to a typed object-tree.\n * It is used after parsing a JSON-string.\n */\nvar deserializer_Deserializer = /** @class */ (function () {\n    function Deserializer() {\n        this._typeResolver = function (sourceObject, knownTypes) {\n            if (sourceObject.__type)\n                return knownTypes.get(sourceObject.__type);\n        };\n        this._errorHandler = function (error) { return logError(error); };\n    }\n    Deserializer.prototype.setNameResolver = function (nameResolverCallback) {\n        this._nameResolver = nameResolverCallback;\n    };\n    Deserializer.prototype.setTypeResolver = function (typeResolverCallback) {\n        if (typeof typeResolverCallback !== \"function\")\n            throw new TypeError(\"'typeResolverCallback' is not a function.\");\n        this._typeResolver = typeResolverCallback;\n    };\n    Deserializer.prototype.setErrorHandler = function (errorHandlerCallback) {\n        if (typeof errorHandlerCallback !== \"function\") {\n            throw new TypeError(\"'errorHandlerCallback' is not a function.\");\n        }\n        this._errorHandler = errorHandlerCallback;\n    };\n    Deserializer.prototype.convertAsObject = function (sourceObject, sourceObjectTypeInfo, objectName, memberOptions) {\n        var _this = this;\n        if (objectName === void 0) { objectName = \"object\"; }\n        if (typeof sourceObject !== \"object\" || sourceObject === null) {\n            this._errorHandler(new TypeError(\"Cannot deserialize \" + objectName + \": 'sourceObject' must be a defined object.\"));\n            return undefined;\n        }\n        var expectedSelfType = sourceObjectTypeInfo.selfConstructor;\n        var sourceObjectMetadata = metadata_JsonObjectMetadata.getFromConstructor(expectedSelfType);\n        var knownTypeConstructors = sourceObjectTypeInfo.knownTypes;\n        if (sourceObjectMetadata) {\n            // Merge known types received from \"above\" with known types defined on the current type.\n            knownTypeConstructors = this._mergeKnownTypes(knownTypeConstructors, this._createKnownTypesMap(sourceObjectMetadata.knownTypes));\n        }\n        // Check if a type-hint is available from the source object.\n        var typeFromTypeHint = this._typeResolver(sourceObject, knownTypeConstructors);\n        if (typeFromTypeHint) {\n            // Check if type hint is a valid subtype of the expected source type.\n            if (isSubtypeOf(typeFromTypeHint, expectedSelfType)) {\n                // Hell yes.\n                expectedSelfType = typeFromTypeHint;\n                sourceObjectMetadata = metadata_JsonObjectMetadata.getFromConstructor(typeFromTypeHint);\n                if (sourceObjectMetadata) {\n                    // Also merge new known types from subtype.\n                    knownTypeConstructors = this._mergeKnownTypes(knownTypeConstructors, this._createKnownTypesMap(sourceObjectMetadata.knownTypes));\n                }\n            }\n        }\n        if (sourceObjectMetadata && sourceObjectMetadata.isExplicitlyMarked) {\n            var sourceMetadata_1 = sourceObjectMetadata;\n            // Strong-typed deserialization available, get to it.\n            // First deserialize properties into a temporary object.\n            var sourceObjectWithDeserializedProperties_1 = {};\n            var classOptions_1 = mergeOptions(this.options, sourceMetadata_1.options);\n            // Deserialize by expected properties.\n            sourceMetadata_1.dataMembers.forEach(function (memberMetadata, propKey) {\n                var memberValue = sourceObject[propKey];\n                var memberNameForDebug = nameof(sourceMetadata_1.classType) + \".\" + propKey;\n                var memberOptions = mergeOptions(classOptions_1, memberMetadata.options);\n                var revivedValue;\n                if (memberMetadata.deserializer) {\n                    revivedValue = memberMetadata.deserializer(memberValue);\n                }\n                else if (memberMetadata.ctor) {\n                    revivedValue = _this.convertSingleValue(memberValue, {\n                        selfConstructor: memberMetadata.ctor,\n                        elementConstructor: memberMetadata.elementType,\n                        keyConstructor: memberMetadata.keyType,\n                        knownTypes: knownTypeConstructors\n                    }, memberNameForDebug, memberOptions);\n                }\n                else {\n                    throw new TypeError(\"Cannot deserialize \" + memberNameForDebug + \" thers is\"\n                        + \" no constructor nor deserlization function to use.\");\n                }\n                if (isValueDefined(revivedValue)\n                    || (_this.retrievePreserveNull(memberOptions) && revivedValue === null)) {\n                    sourceObjectWithDeserializedProperties_1[memberMetadata.key] = revivedValue;\n                }\n                else if (memberMetadata.isRequired) {\n                    _this._errorHandler(new TypeError(\"Missing required member '\" + memberNameForDebug + \"'.\"));\n                }\n            });\n            // Next, instantiate target object.\n            var targetObject = void 0;\n            if (typeof sourceObjectMetadata.initializerCallback === \"function\") {\n                try {\n                    targetObject = sourceObjectMetadata.initializerCallback(sourceObjectWithDeserializedProperties_1, sourceObject);\n                    // Check the validity of user-defined initializer callback.\n                    if (!targetObject) {\n                        throw new TypeError(\"Cannot deserialize \" + objectName + \":\"\n                            + \" 'initializer' function returned undefined/null\"\n                            + (\", but '\" + nameof(sourceObjectMetadata.classType) + \"' was expected.\"));\n                    }\n                    else if (!(targetObject instanceof sourceObjectMetadata.classType)) {\n                        throw new TypeError(\"Cannot deserialize \" + objectName + \":\"\n                            + (\"'initializer' returned '\" + nameof(targetObject.constructor) + \"'\")\n                            + (\", but '\" + nameof(sourceObjectMetadata.classType) + \"' was expected\")\n                            + (\", and '\" + nameof(targetObject.constructor) + \"' is not a subtype of\")\n                            + (\" '\" + nameof(sourceObjectMetadata.classType) + \"'\"));\n                    }\n                }\n                catch (e) {\n                    this._errorHandler(e);\n                    return undefined;\n                }\n            }\n            else {\n                targetObject = this._instantiateType(expectedSelfType);\n            }\n            // Finally, assign deserialized properties to target object.\n            Object.assign(targetObject, sourceObjectWithDeserializedProperties_1);\n            // Call onDeserialized method (if any).\n            if (sourceObjectMetadata.onDeserializedMethodName) {\n                // check for member first\n                if (typeof targetObject[sourceObjectMetadata.onDeserializedMethodName] === \"function\") {\n                    targetObject[sourceObjectMetadata.onDeserializedMethodName]();\n                }\n                // check for static\n                else if (typeof targetObject.constructor[sourceObjectMetadata.onDeserializedMethodName] === \"function\") {\n                    targetObject.constructor[sourceObjectMetadata.onDeserializedMethodName]();\n                }\n                else {\n                    this._errorHandler(new TypeError(\"onDeserialized callback '\" + nameof(sourceObjectMetadata.classType) + \".\" + sourceObjectMetadata.onDeserializedMethodName + \"' is not a method.\"));\n                }\n            }\n            return targetObject;\n        }\n        else {\n            // Untyped deserialization into Object instance.\n            var targetObject_1 = {};\n            Object.keys(sourceObject).forEach(function (sourceKey) {\n                targetObject_1[sourceKey] = _this.convertSingleValue(sourceObject[sourceKey], {\n                    selfConstructor: sourceObject[sourceKey].constructor,\n                    knownTypes: sourceObjectTypeInfo.knownTypes,\n                    elementConstructor: sourceObjectTypeInfo.elementConstructor,\n                    keyConstructor: sourceObjectTypeInfo.keyConstructor\n                }, sourceKey);\n            });\n            return targetObject_1;\n        }\n    };\n    Deserializer.prototype.convertSingleValue = function (sourceObject, typeInfo, memberName, memberOptions) {\n        if (memberName === void 0) { memberName = \"object\"; }\n        var expectedSelfType = typeInfo.selfConstructor;\n        var srcTypeNameForDebug = sourceObject ? nameof(sourceObject.constructor) : \"undefined\";\n        if (this.retrievePreserveNull(memberOptions) && sourceObject === null) {\n            return null;\n        }\n        else if (!isValueDefined(sourceObject)) {\n            return;\n        }\n        else if (this._isDirectlyDeserializableNativeType(expectedSelfType)) {\n            if (sourceObject.constructor === expectedSelfType) {\n                return sourceObject;\n            }\n            else {\n                throw new TypeError(this._makeTypeErrorMessage(nameof(expectedSelfType), sourceObject.constructor, memberName));\n            }\n        }\n        else if (expectedSelfType === Date) {\n            // Support for Date with ISO 8601 format, or with numeric timestamp (milliseconds elapsed since the Epoch).\n            // ISO 8601 spec.: https://www.w3.org/TR/NOTE-datetime\n            if (typeof sourceObject === \"string\" || (typeof sourceObject === \"number\" && sourceObject > 0))\n                return new Date(sourceObject);\n            else\n                this._throwTypeMismatchError(\"Date\", \"an ISO-8601 string\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Float32Array) {\n            // Deserialize Float32Array from number[].\n            if (sourceObject instanceof Array && sourceObject.every(function (elem) { return !isNaN(elem); }))\n                return new Float32Array(sourceObject);\n            else\n                this._throwTypeMismatchError(\"Float32Array\", \"a numeric source array\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Float64Array) {\n            // Deserialize Float64Array from number[].\n            if (sourceObject instanceof Array && sourceObject.every(function (elem) { return !isNaN(elem); }))\n                return new Float64Array(sourceObject);\n            else\n                this._throwTypeMismatchError(\"Float64Array\", \"a numeric source array\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Uint8Array) {\n            // Deserialize Uint8Array from number[].\n            if (sourceObject instanceof Array && sourceObject.every(function (elem) { return !isNaN(elem); }))\n                return new Uint8Array(sourceObject.map(function (value) { return ~~value; }));\n            else\n                this._throwTypeMismatchError(\"Uint8Array\", \"a numeric source array\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Uint8ClampedArray) {\n            // Deserialize Uint8Array from number[].\n            if (sourceObject instanceof Array && sourceObject.every(function (elem) { return !isNaN(elem); }))\n                return new Uint8ClampedArray(sourceObject.map(function (value) { return ~~value; }));\n            else\n                this._throwTypeMismatchError(\"Uint8ClampedArray\", \"a numeric source array\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Uint16Array) {\n            // Deserialize Uint16Array from number[].\n            if (sourceObject instanceof Array && sourceObject.every(function (elem) { return !isNaN(elem); }))\n                return new Uint16Array(sourceObject.map(function (value) { return ~~value; }));\n            else\n                this._throwTypeMismatchError(\"Uint16Array\", \"a numeric source array\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Uint32Array) {\n            // Deserialize Uint32Array from number[].\n            if (sourceObject instanceof Array && sourceObject.every(function (elem) { return !isNaN(elem); }))\n                return new Uint32Array(sourceObject.map(function (value) { return ~~value; }));\n            else\n                this._throwTypeMismatchError(\"Uint32Array\", \"a numeric source array\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === ArrayBuffer) {\n            if (typeof sourceObject === \"string\")\n                return this._stringToArrayBuffer(sourceObject);\n            else\n                this._throwTypeMismatchError(\"ArrayBuffer\", \"a string source\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === DataView) {\n            if (typeof sourceObject === \"string\")\n                return this._stringToDataView(sourceObject);\n            else\n                this._throwTypeMismatchError(\"DataView\", \"a string source\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Array) {\n            if (sourceObject instanceof Array)\n                return this.convertAsArray(sourceObject, typeInfo, memberName, memberOptions);\n            else\n                throw new TypeError(this._makeTypeErrorMessage(Array, sourceObject.constructor, memberName));\n        }\n        else if (expectedSelfType === Set) {\n            if (sourceObject instanceof Array)\n                return this.convertAsSet(sourceObject, typeInfo, memberName, memberOptions);\n            else\n                this._throwTypeMismatchError(\"Set\", \"Array\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Map) {\n            if (sourceObject instanceof Array)\n                return this.convertAsMap(sourceObject, typeInfo, memberName, memberOptions);\n            else\n                this._throwTypeMismatchError(\"Map\", \"a source array of key-value-pair objects\", srcTypeNameForDebug, memberName);\n        }\n        else if (sourceObject && typeof sourceObject === \"object\") {\n            return this.convertAsObject(sourceObject, typeInfo, memberName, memberOptions);\n        }\n    };\n    Deserializer.prototype.convertAsArray = function (sourceObject, typeInfo, memberName, memberOptions) {\n        var _this = this;\n        if (memberName === void 0) { memberName = \"object\"; }\n        if (!(sourceObject instanceof Array)) {\n            this._errorHandler(new TypeError(this._makeTypeErrorMessage(Array, sourceObject.constructor, memberName)));\n            return [];\n        }\n        if (!typeInfo.elementConstructor || !typeInfo.elementConstructor.length) {\n            this._errorHandler(new TypeError(\"Could not deserialize \" + memberName + \" as Array: missing constructor reference of Array elements.\"));\n            return [];\n        }\n        var elementTypeInfo = {\n            selfConstructor: typeInfo.elementConstructor[0],\n            elementConstructor: (typeInfo.elementConstructor.length > 1) ? typeInfo.elementConstructor.slice(1) : [],\n            knownTypes: typeInfo.knownTypes\n        };\n        return sourceObject.map(function (element) {\n            // If an array element fails to deserialize, substitute with undefined. This is so that the original ordering is not interrupted by faulty\n            // entries, as an Array is ordered.\n            try {\n                return _this.convertSingleValue(element, elementTypeInfo, memberName + \"[]\", memberOptions);\n            }\n            catch (e) {\n                _this._errorHandler(e);\n                // Keep filling the array here with undefined to keep original ordering.\n                // Note: this is just aesthetics, not returning anything produces the same result.\n                return undefined;\n            }\n        });\n    };\n    Deserializer.prototype.convertAsSet = function (sourceObject, typeInfo, memberName, memberOptions) {\n        var _this = this;\n        if (memberName === void 0) { memberName = \"object\"; }\n        if (!(sourceObject instanceof Array)) {\n            this._errorHandler(new TypeError(this._makeTypeErrorMessage(Array, sourceObject.constructor, memberName)));\n            return new Set();\n        }\n        if (!typeInfo.elementConstructor || !typeInfo.elementConstructor.length) {\n            this._errorHandler(new TypeError(\"Could not deserialize \" + memberName + \" as Set: missing constructor reference of Set elements.\"));\n            return new Set();\n        }\n        var elementTypeInfo = {\n            selfConstructor: typeInfo.elementConstructor[0],\n            elementConstructor: (typeInfo.elementConstructor.length > 1) ? typeInfo.elementConstructor.slice(1) : [],\n            knownTypes: typeInfo.knownTypes\n        };\n        var resultSet = new Set();\n        sourceObject.forEach(function (element, i) {\n            try {\n                resultSet.add(_this.convertSingleValue(element, elementTypeInfo, memberName + \"[\" + i + \"]\", memberOptions));\n            }\n            catch (e) {\n                // Faulty entries are skipped, because a Set is not ordered, and skipping an entry\n                // does not affect others.\n                _this._errorHandler(e);\n            }\n        });\n        return resultSet;\n    };\n    Deserializer.prototype.convertAsMap = function (sourceObject, typeInfo, memberName, memberOptions) {\n        var _this = this;\n        if (memberName === void 0) { memberName = \"object\"; }\n        if (!(sourceObject instanceof Array))\n            this._errorHandler(new TypeError(this._makeTypeErrorMessage(Array, sourceObject.constructor, memberName)));\n        if (!typeInfo.keyConstructor) {\n            this._errorHandler(new TypeError(\"Could not deserialize \" + memberName + \" as Map: missing key constructor.\"));\n            return new Map();\n        }\n        if (!typeInfo.elementConstructor || !typeInfo.elementConstructor.length) {\n            this._errorHandler(new TypeError(\"Could not deserialize \" + memberName + \" as Map: missing value constructor.\"));\n            return new Map();\n        }\n        var keyTypeInfo = {\n            selfConstructor: typeInfo.keyConstructor,\n            knownTypes: typeInfo.knownTypes\n        };\n        var valueTypeInfo = {\n            selfConstructor: typeInfo.elementConstructor[0],\n            elementConstructor: (typeInfo.elementConstructor.length > 1) ? typeInfo.elementConstructor.slice(1) : [],\n            knownTypes: typeInfo.knownTypes\n        };\n        var resultMap = new Map();\n        sourceObject.forEach(function (element) {\n            try {\n                var key = _this.convertSingleValue(element.key, keyTypeInfo, memberName, memberOptions);\n                // Undefined/null keys not supported, skip if so.\n                if (isValueDefined(key)) {\n                    resultMap.set(key, _this.convertSingleValue(element.value, valueTypeInfo, memberName + \"[\" + key + \"]\", memberOptions));\n                }\n            }\n            catch (e) {\n                // Faulty entries are skipped, because a Map is not ordered,\n                // and skipping an entry does not affect others.\n                _this._errorHandler(e);\n            }\n        });\n        return resultMap;\n    };\n    Deserializer.prototype._throwTypeMismatchError = function (targetType, expectedSourceType, actualSourceType, memberName) {\n        if (memberName === void 0) { memberName = \"object\"; }\n        throw new TypeError(\"Could not deserialize \" + memberName + \" as \" + targetType + \":\"\n            + (\" expected \" + expectedSourceType + \", got \" + actualSourceType + \".\"));\n    };\n    Deserializer.prototype._makeTypeErrorMessage = function (expectedType, actualType, memberName) {\n        if (memberName === void 0) { memberName = \"object\"; }\n        var expectedTypeName = (typeof expectedType === \"function\") ? nameof(expectedType) : expectedType;\n        var actualTypeName = (typeof actualType === \"function\") ? nameof(actualType) : actualType;\n        return \"Could not deserialize \" + memberName + \": expected '\" + expectedTypeName + \"', got '\" + actualTypeName + \"'.\";\n    };\n    Deserializer.prototype._instantiateType = function (ctor) {\n        return new ctor();\n    };\n    Deserializer.prototype._mergeKnownTypes = function () {\n        var _this = this;\n        var knownTypeMaps = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            knownTypeMaps[_i] = arguments[_i];\n        }\n        var result = new Map();\n        knownTypeMaps.forEach(function (knownTypes) {\n            knownTypes.forEach(function (ctor, name) {\n                if (_this._nameResolver) {\n                    result.set(_this._nameResolver(ctor), ctor);\n                }\n                else {\n                    result.set(name, ctor);\n                }\n            });\n        });\n        return result;\n    };\n    Deserializer.prototype._createKnownTypesMap = function (knowTypes) {\n        var _this = this;\n        var map = new Map();\n        knowTypes.forEach(function (ctor) {\n            if (_this._nameResolver) {\n                map.set(_this._nameResolver(ctor), ctor);\n            }\n            else {\n                var knownTypeMeta = metadata_JsonObjectMetadata.getFromConstructor(ctor);\n                var name_1 = knownTypeMeta && knownTypeMeta.isExplicitlyMarked && knownTypeMeta.name\n                    ? knownTypeMeta.name\n                    : ctor.name;\n                map.set(name_1, ctor);\n            }\n        });\n        return map;\n    };\n    Deserializer.prototype._isDirectlyDeserializableNativeType = function (ctor) {\n        return ~([Number, String, Boolean].indexOf(ctor));\n    };\n    Deserializer.prototype.convertNativeObject = function (sourceObject) {\n        return sourceObject;\n    };\n    Deserializer.prototype._stringToArrayBuffer = function (str) {\n        var buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char\n        var bufView = new Uint16Array(buf);\n        for (var i = 0, strLen = str.length; i < strLen; i++) {\n            bufView[i] = str.charCodeAt(i);\n        }\n        return buf;\n    };\n    Deserializer.prototype._stringToDataView = function (str) {\n        return new DataView(this._stringToArrayBuffer(str));\n    };\n    Deserializer.prototype.retrievePreserveNull = function (memberOptions) {\n        return getOptionValue('preserveNull', mergeOptions(this.options, memberOptions));\n    };\n    return Deserializer;\n}());\n\n\n// CONCATENATED MODULE: ./src/parser.ts\nvar parser_assign = (undefined && undefined.__assign) || function () {\n    parser_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return parser_assign.apply(this, arguments);\n};\n\n\n\n\n\nvar parser_TypedJSON = /** @class */ (function () {\n    /**\n     * Creates a new TypedJSON instance to serialize (stringify) and deserialize (parse) object\n     *     instances of the specified root class type.\n     * @param rootType The constructor of the root class type.\n     * @param settings Additional configuration settings.\n     */\n    function TypedJSON(rootConstructor, settings) {\n        //#endregion\n        this.serializer = new serializer_Serializer();\n        this.deserializer = new deserializer_Deserializer();\n        this.globalKnownTypes = [];\n        this.indent = 0;\n        var rootMetadata = metadata_JsonObjectMetadata.getFromConstructor(rootConstructor);\n        if (!rootMetadata || (!rootMetadata.isExplicitlyMarked && !rootMetadata.isHandledWithoutAnnotation)) {\n            throw new TypeError(\"The TypedJSON root data type must have the @jsonObject decorator used.\");\n        }\n        this.nameResolver = function (ctor) { return nameof(ctor); };\n        this.rootConstructor = rootConstructor;\n        this.errorHandler = function (error) { return logError(error); };\n        if (settings) {\n            this.config(settings);\n        }\n        else if (TypedJSON._globalConfig) {\n            this.config({});\n        }\n    }\n    //#region Static\n    TypedJSON.parse = function (object, rootType, settings) {\n        return new TypedJSON(rootType, settings).parse(object);\n    };\n    TypedJSON.parseAsArray = function (object, elementType, settings, dimensions) {\n        return new TypedJSON(elementType, settings).parseAsArray(object, dimensions);\n    };\n    TypedJSON.parseAsSet = function (object, elementType, settings) {\n        return new TypedJSON(elementType, settings).parseAsSet(object);\n    };\n    TypedJSON.parseAsMap = function (object, keyType, valueType, settings) {\n        return new TypedJSON(valueType, settings).parseAsMap(object, keyType);\n    };\n    TypedJSON.toPlainJson = function (object, rootType, settings) {\n        return new TypedJSON(rootType, settings).toPlainJson(object);\n    };\n    TypedJSON.toPlainArray = function (object, elementType, dimensions, settings) {\n        return new TypedJSON(elementType, settings).toPlainArray(object, dimensions);\n    };\n    TypedJSON.toPlainSet = function (object, elementType, settings) {\n        return new TypedJSON(elementType, settings).toPlainSet(object);\n    };\n    TypedJSON.toPlainMap = function (object, keyCtor, valueCtor, settings) {\n        return new TypedJSON(valueCtor, settings).toPlainMap(object, keyCtor);\n    };\n    TypedJSON.stringify = function (object, rootType, settings) {\n        return new TypedJSON(rootType, settings).stringify(object);\n    };\n    TypedJSON.stringifyAsArray = function (object, elementType, dimensions, settings) {\n        return new TypedJSON(elementType, settings).stringifyAsArray(object, dimensions);\n    };\n    TypedJSON.stringifyAsSet = function (object, elementType, settings) {\n        return new TypedJSON(elementType, settings).stringifyAsSet(object);\n    };\n    TypedJSON.stringifyAsMap = function (object, keyCtor, valueCtor, settings) {\n        return new TypedJSON(valueCtor, settings).stringifyAsMap(object, keyCtor);\n    };\n    TypedJSON.setGlobalConfig = function (config) {\n        if (this._globalConfig) {\n            Object.assign(this._globalConfig, config);\n        }\n        else {\n            this._globalConfig = config;\n        }\n    };\n    /**\n     * Configures TypedJSON through a settings object.\n     * @param settings The configuration settings object.\n     */\n    TypedJSON.prototype.config = function (settings) {\n        if (TypedJSON._globalConfig) {\n            settings = parser_assign({}, TypedJSON._globalConfig, settings);\n            if (settings.knownTypes && TypedJSON._globalConfig.knownTypes) {\n                // Merge known-types (also de-duplicate them, so Array -> Set -> Array).\n                settings.knownTypes = Array.from(new Set(settings.knownTypes.concat(TypedJSON._globalConfig.knownTypes)));\n            }\n        }\n        var options = extractOptionBase(settings);\n        this.serializer.options = options;\n        this.deserializer.options = options;\n        if (settings.errorHandler) {\n            this.errorHandler = settings.errorHandler;\n            this.deserializer.setErrorHandler(settings.errorHandler);\n            this.serializer.setErrorHandler(settings.errorHandler);\n        }\n        if (settings.replacer)\n            this.replacer = settings.replacer;\n        if (settings.typeResolver)\n            this.deserializer.setTypeResolver(settings.typeResolver);\n        if (settings.typeHintEmitter)\n            this.serializer.setTypeHintEmitter(settings.typeHintEmitter);\n        if (settings.indent)\n            this.indent = settings.indent;\n        if (settings.nameResolver) {\n            this.nameResolver = settings.nameResolver;\n            this.deserializer.setNameResolver(settings.nameResolver);\n            // this.serializer.set\n        }\n        if (settings.knownTypes) {\n            // Type-check knownTypes elements to recognize errors in advance.\n            settings.knownTypes.forEach(function (knownType, i) {\n                // tslint:disable-next-line:no-null-keyword\n                if (typeof knownType === \"undefined\" || knownType === null) {\n                    logWarning(\"TypedJSON.config: 'knownTypes' contains an undefined/null value (element \" + i + \").\");\n                }\n            });\n            this.globalKnownTypes = settings.knownTypes;\n        }\n    };\n    /**\n     * Converts a JSON string to the root class type.\n     * @param object The JSON to parse and convert.\n     * @throws Error if any errors are thrown in the specified errorHandler callback (re-thrown).\n     * @returns Deserialized T or undefined if there were errors.\n     */\n    TypedJSON.prototype.parse = function (object) {\n        var _this = this;\n        var json = parseToJSObject(object, this.rootConstructor);\n        var rootMetadata = metadata_JsonObjectMetadata.getFromConstructor(this.rootConstructor);\n        var result;\n        var knownTypes = new Map();\n        this.globalKnownTypes.filter(function (ktc) { return ktc; }).forEach(function (knownTypeCtor) {\n            knownTypes.set(_this.nameResolver(knownTypeCtor), knownTypeCtor);\n        });\n        if (rootMetadata) {\n            rootMetadata.knownTypes.forEach(function (knownTypeCtor) {\n                knownTypes.set(_this.nameResolver(knownTypeCtor), knownTypeCtor);\n            });\n        }\n        try {\n            result = this.deserializer.convertSingleValue(json, {\n                selfConstructor: this.rootConstructor,\n                knownTypes: knownTypes,\n            });\n        }\n        catch (e) {\n            this.errorHandler(e);\n        }\n        return result;\n    };\n    TypedJSON.prototype.parseAsArray = function (object, dimensions) {\n        if (dimensions === void 0) { dimensions = 1; }\n        var json = parseToJSObject(object, Array);\n        if (json instanceof Array) {\n            return this.deserializer.convertAsArray(json, {\n                selfConstructor: Array,\n                elementConstructor: new Array(dimensions - 1)\n                    .fill(Array)\n                    .concat(this.rootConstructor),\n                knownTypes: this._mapKnownTypes(this.globalKnownTypes),\n            });\n        }\n        else {\n            this.errorHandler(new TypeError(\"Expected 'json' to define an Array\"\n                + (\", but got \" + typeof json + \".\")));\n        }\n        return [];\n    };\n    TypedJSON.prototype.parseAsSet = function (object) {\n        var json = parseToJSObject(object, Set);\n        // A Set<T> is serialized as T[].\n        if (json instanceof Array) {\n            return this.deserializer.convertAsSet(json, {\n                selfConstructor: Array,\n                elementConstructor: [this.rootConstructor],\n                knownTypes: this._mapKnownTypes(this.globalKnownTypes)\n            });\n        }\n        else {\n            this.errorHandler(new TypeError(\"Expected 'json' to define a Set (using an Array)\"\n                + (\", but got \" + typeof json + \".\")));\n        }\n        return new Set();\n    };\n    TypedJSON.prototype.parseAsMap = function (object, keyConstructor) {\n        var json = parseToJSObject(object, Map);\n        // A Set<T> is serialized as T[].\n        if (json instanceof Array) {\n            return this.deserializer.convertAsMap(json, {\n                selfConstructor: Array,\n                elementConstructor: [this.rootConstructor],\n                knownTypes: this._mapKnownTypes(this.globalKnownTypes),\n                keyConstructor: keyConstructor\n            });\n        }\n        else {\n            this.errorHandler(new TypeError(\"Expected 'json' to define a Set (using an Array)\"\n                + (\", but got \" + typeof json + \".\")));\n        }\n        return new Map();\n    };\n    /**\n     * Converts an instance of the specified class type to a plain JSON object.\n     * @param object The instance to convert to a JSON string.\n     * @returns Serialized object or undefined if an error has occured.\n     */\n    TypedJSON.prototype.toPlainJson = function (object) {\n        try {\n            return this.serializer.convertSingleValue(object, { selfType: this.rootConstructor });\n        }\n        catch (e) {\n            this.errorHandler(e);\n        }\n    };\n    TypedJSON.prototype.toPlainArray = function (object, dimensions) {\n        if (dimensions === void 0) { dimensions = 1; }\n        try {\n            var elementConstructorArray = new Array(dimensions - 1).fill(Array).concat(this.rootConstructor);\n            return this.serializer.convertAsArray(object, elementConstructorArray);\n        }\n        catch (e) {\n            this.errorHandler(e);\n        }\n    };\n    TypedJSON.prototype.toPlainSet = function (object) {\n        try {\n            return this.serializer.convertAsSet(object, this.rootConstructor);\n        }\n        catch (e) {\n            this.errorHandler(e);\n        }\n    };\n    TypedJSON.prototype.toPlainMap = function (object, keyConstructor) {\n        try {\n            return this.serializer.convertAsMap(object, keyConstructor, this.rootConstructor);\n        }\n        catch (e) {\n            this.errorHandler(e);\n        }\n    };\n    /**\n     * Converts an instance of the specified class type to a JSON string.\n     * @param object The instance to convert to a JSON string.\n     * @throws Error if any errors are thrown in the specified errorHandler callback (re-thrown).\n     * @returns String with the serialized object or an empty string if an error has occured, but\n     *     the errorHandler did not throw.\n     */\n    TypedJSON.prototype.stringify = function (object) {\n        var result = this.toPlainJson(object);\n        if (result === undefined) {\n            return '';\n        }\n        return JSON.stringify(result, this.replacer, this.indent);\n    };\n    TypedJSON.prototype.stringifyAsArray = function (object, dimensions) {\n        return JSON.stringify(this.toPlainArray(object, dimensions), this.replacer, this.indent);\n    };\n    TypedJSON.prototype.stringifyAsSet = function (object) {\n        return JSON.stringify(this.toPlainSet(object), this.replacer, this.indent);\n    };\n    TypedJSON.prototype.stringifyAsMap = function (object, keyConstructor) {\n        return JSON.stringify(this.toPlainMap(object, keyConstructor), this.replacer, this.indent);\n    };\n    TypedJSON.prototype._mapKnownTypes = function (constructors) {\n        var _this = this;\n        var map = new Map();\n        constructors.filter(function (ctor) { return ctor; }).forEach(function (ctor) { return map.set(_this.nameResolver(ctor), ctor); });\n        return map;\n    };\n    return TypedJSON;\n}());\n\n\n// CONCATENATED MODULE: ./src/typedjson/json-object.ts\n\n\n\nfunction jsonObject(optionsOrTarget) {\n    var options;\n    if (typeof optionsOrTarget === \"function\") {\n        // jsonObject is being used as a decorator, directly.\n        options = {};\n    }\n    else {\n        // jsonObject is being used as a decorator factory.\n        options = optionsOrTarget || {};\n    }\n    function decorator(target) {\n        var objectMetadata;\n        // Create or obtain JsonObjectMetadata object.\n        if (!target.prototype.hasOwnProperty(METADATA_FIELD_KEY)) {\n            // Target has no JsonObjectMetadata associated with it yet, create it now.\n            objectMetadata = new metadata_JsonObjectMetadata(target);\n            // Inherit json members and known types from parent @jsonObject (if any).\n            var parentMetadata = target.prototype[METADATA_FIELD_KEY];\n            if (parentMetadata) {\n                parentMetadata.dataMembers\n                    .forEach(function (memberMetadata, propKey) {\n                    return objectMetadata.dataMembers.set(propKey, memberMetadata);\n                });\n                parentMetadata.knownTypes\n                    .forEach(function (knownType) { return objectMetadata.knownTypes.add(knownType); });\n            }\n            Object.defineProperty(target.prototype, METADATA_FIELD_KEY, {\n                enumerable: false,\n                configurable: false,\n                writable: false,\n                value: objectMetadata\n            });\n        }\n        else {\n            // Target already has JsonObjectMetadata associated with it.\n            objectMetadata = target.prototype[METADATA_FIELD_KEY];\n            objectMetadata.classType = target;\n        }\n        // Fill JsonObjectMetadata.\n        objectMetadata.isExplicitlyMarked = true;\n        objectMetadata.onDeserializedMethodName = options.onDeserialized;\n        objectMetadata.beforeSerializationMethodName = options.beforeSerialization;\n        // T extend Object so it is fine\n        objectMetadata.initializerCallback = options.initializer;\n        if (options.name) {\n            objectMetadata.name = options.name;\n        }\n        var optionsBase = extractOptionBase(options);\n        if (optionsBase) {\n            objectMetadata.options = optionsBase;\n        }\n        // Obtain known-types.\n        if (typeof options.knownTypes === \"string\") {\n            objectMetadata.knownTypeMethodName = options.knownTypes;\n        }\n        else if (options.knownTypes instanceof Array) {\n            options.knownTypes\n                .filter(function (knownType) { return !!knownType; })\n                .forEach(function (knownType) { return objectMetadata.knownTypes.add(knownType); });\n        }\n    }\n    if (typeof optionsOrTarget === \"function\") {\n        // jsonObject is being used as a decorator, directly.\n        decorator(optionsOrTarget);\n    }\n    else {\n        // jsonObject is being used as a decorator factory.\n        return decorator;\n    }\n}\n\n// CONCATENATED MODULE: ./src/typedjson/json-member.ts\n\n\n\nfunction jsonMember(optionsOrTarget, propKey) {\n    if (optionsOrTarget instanceof Object && (typeof propKey === \"string\" || typeof propKey === \"symbol\")) {\n        var target = optionsOrTarget;\n        // For error messages.\n        var decoratorName = \"@jsonMember on \" + nameof(target.constructor) + \".\" + String(propKey);\n        // jsonMember used directly, no additional information directly available besides target and propKey.\n        // Obtain property constructor through ReflectDecorators.\n        if (isReflectMetadataSupported) {\n            var reflectPropCtor = Reflect.getMetadata(\"design:type\", target, propKey);\n            if (!reflectPropCtor) {\n                logError(decoratorName + \": could not resolve detected property constructor at runtime.\");\n                return;\n            }\n            if (isSpecialPropertyType(decoratorName, reflectPropCtor)) {\n                return;\n            }\n            injectMetadataInformation(target, propKey, {\n                ctor: reflectPropCtor,\n                key: propKey.toString(),\n                name: propKey.toString(),\n            });\n        }\n        else {\n            logError(decoratorName + \": ReflectDecorators is required if no 'constructor' option is specified.\");\n            return;\n        }\n    }\n    else {\n        // jsonMember used as a decorator factory.\n        return function (target, _propKey) {\n            var options = optionsOrTarget || {};\n            var propCtor;\n            var decoratorName = \"@jsonMember on \" + nameof(target.constructor) + \".\" + String(_propKey); // For error messages.\n            if (options.hasOwnProperty(\"constructor\")) {\n                if (!isValueDefined(options.constructor)) {\n                    logError(decoratorName + \": cannot resolve specified property constructor at runtime.\");\n                    return;\n                }\n                // Property constructor has been specified. Use ReflectDecorators (if available) to check whether that constructor is correct. Warn if not.\n                if (isReflectMetadataSupported && !isSubtypeOf(options.constructor, Reflect.getMetadata(\"design:type\", target, _propKey))) {\n                    logWarning(decoratorName + \": detected property type does not match 'constructor' option.\");\n                }\n                propCtor = options.constructor;\n            }\n            else {\n                // Use ReflectDecorators to obtain property constructor.\n                if (isReflectMetadataSupported) {\n                    propCtor = Reflect.getMetadata(\"design:type\", target, _propKey);\n                    if (!propCtor) {\n                        logError(decoratorName + \": cannot resolve detected property constructor at runtime.\");\n                        return;\n                    }\n                }\n                else if (!options.deserializer) {\n                    logError(decoratorName + \": ReflectDecorators is required if no 'constructor' option is specified.\");\n                    return;\n                }\n            }\n            if (isSpecialPropertyType(decoratorName, propCtor)) {\n                return;\n            }\n            injectMetadataInformation(target, _propKey, {\n                ctor: propCtor,\n                emitDefaultValue: options.emitDefaultValue,\n                isRequired: options.isRequired,\n                options: extractOptionBase(options),\n                key: _propKey.toString(),\n                name: options.name || _propKey.toString(),\n                deserializer: options.deserializer,\n                serializer: options.serializer,\n            });\n        };\n    }\n}\nfunction isSpecialPropertyType(decoratorName, propCtor) {\n    if (propCtor === Array) {\n        logError(decoratorName + \": property is an Array. Use the jsonArrayMember decorator to\"\n            + \" serialize this property.\");\n        return true;\n    }\n    if (propCtor === Set) {\n        logError(decoratorName + \": property is a Set. Use the jsonSetMember decorator to\"\n            + \" serialize this property.\");\n        return true;\n    }\n    if (propCtor === Map) {\n        logError(decoratorName + \": property is a Map. Use the jsonMapMember decorator to\"\n            + \" serialize this property.\");\n        return true;\n    }\n    return false;\n}\n\n// CONCATENATED MODULE: ./src/typedjson/json-array-member.ts\n\n\n\n/**\n * Specifies that a property, of type array, is part of an object when serializing.\n * @param elementConstructor Constructor of array elements (e.g. 'Number' for 'number[]', or 'Date' for 'Date[]').\n * @param options Additional options.\n */\nfunction jsonArrayMember(elementConstructor, options) {\n    if (options === void 0) { options = {}; }\n    return function (target, propKey) {\n        var decoratorName = \"@jsonArrayMember on \" + nameof(target.constructor) + \".\" + String(propKey); // For error messages.\n        if (typeof elementConstructor !== \"function\") {\n            logError(decoratorName + \": could not resolve constructor of array elements at runtime.\");\n            return;\n        }\n        var dimensions = options.dimensions === undefined ? 1 : options.dimensions;\n        if (!isNaN(dimensions) && dimensions < 1) {\n            logError(decoratorName + \": 'dimensions' option must be at least 1.\");\n            return;\n        }\n        // If ReflectDecorators is available, use it to check whether 'jsonArrayMember' has been used on an array.\n        if (isReflectMetadataSupported && Reflect.getMetadata(\"design:type\", target, propKey) !== Array) {\n            logError(decoratorName + \": property is not an Array.\");\n            return;\n        }\n        injectMetadataInformation(target, propKey, {\n            ctor: Array,\n            elementType: createArrayElementType(elementConstructor, dimensions),\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: options.name || propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\nfunction createArrayElementType(elementCtor, dimensions) {\n    var elementTypes = new Array(dimensions).fill(Array, 0, -1);\n    elementTypes[dimensions - 1] = elementCtor;\n    return elementTypes;\n}\n\n// CONCATENATED MODULE: ./src/typedjson/json-set-member.ts\n\n\n\n/**\n * Specifies that the property is part of the object when serializing.\n * Use this decorator on properties of type Set<T>.\n * @param elementConstructor Constructor of set elements (e.g. 'Number' for Set<number> or 'Date' for Set<Date>).\n * @param options Additional options.\n */\nfunction jsonSetMember(elementConstructor, options) {\n    if (options === void 0) { options = {}; }\n    return function (target, propKey) {\n        var decoratorName = \"@jsonSetMember on \" + nameof(target.constructor) + \".\" + String(propKey); // For error messages.\n        if (typeof elementConstructor !== \"function\") {\n            logError(decoratorName + \": could not resolve constructor of set elements at runtime.\");\n            return;\n        }\n        // If ReflectDecorators is available, use it to check whether 'jsonSetMember' has been used on a set. Warn if not.\n        if (isReflectMetadataSupported && Reflect.getMetadata(\"design:type\", target, propKey) !== Set) {\n            logError(decoratorName + \": property is not a Set.\");\n            return;\n        }\n        injectMetadataInformation(target, propKey, {\n            ctor: Set,\n            elementType: [elementConstructor],\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: options.name || propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\n\n// CONCATENATED MODULE: ./src/typedjson/json-map-member.ts\n\n\n\n/**\n * Specifies that the property is part of the object when serializing.\n * Use this decorator on properties of type Map<K, V>.\n * @param keyConstructor Constructor of map keys (e.g. 'Number' for 'Map<number, Date>').\n * @param valueConstructor Constructor of map values (e.g. 'Date' for 'Map<number, Date>').\n * @param options Additional options.\n */\nfunction jsonMapMember(keyConstructor, valueConstructor, options) {\n    if (options === void 0) { options = {}; }\n    return function (target, propKey) {\n        var decoratorName = \"@jsonMapMember on \" + nameof(target.constructor) + \".\" + String(propKey); // For error messages.\n        if (typeof keyConstructor !== \"function\") {\n            logError(decoratorName + \": could not resolve constructor of map keys at runtime.\");\n            return;\n        }\n        if (typeof valueConstructor !== \"function\") {\n            logError(decoratorName + \": could not resolve constructor of map values at runtime.\");\n            return;\n        }\n        // If ReflectDecorators is available, use it to check whether 'jsonMapMember' has been used on a map. Warn if not.\n        if (isReflectMetadataSupported && Reflect.getMetadata(\"design:type\", target, propKey) !== Map) {\n            logError(decoratorName + \": property is not a Map.\");\n            return;\n        }\n        injectMetadataInformation(target, propKey, {\n            ctor: Map,\n            elementType: [valueConstructor],\n            keyType: keyConstructor,\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: options.name || propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\n\n// CONCATENATED MODULE: ./src/typedjson/to-json.ts\n\nfunction toJson(optionsOrTarget) {\n    if (typeof optionsOrTarget === 'function') {\n        // used directly\n        toJsonDecorator(optionsOrTarget, {});\n        return;\n    }\n    // used as a factory\n    return function (target) {\n        toJsonDecorator(target, optionsOrTarget);\n    };\n}\nfunction toJsonDecorator(target, options) {\n    if (!options.overwrite && target.prototype.toJSON) {\n        throw new Error(target.name + \" already has toJSON defined!\");\n    }\n    target.prototype.toJSON = function () {\n        return parser_TypedJSON.toPlainJson(this, Object.getPrototypeOf(this).constructor);\n    };\n}\n\n// CONCATENATED MODULE: ./src/typedjson.ts\n/* concated harmony reexport TypedJSON */__webpack_require__.d(__webpack_exports__, \"TypedJSON\", function() { return parser_TypedJSON; });\n/* concated harmony reexport jsonObject */__webpack_require__.d(__webpack_exports__, \"jsonObject\", function() { return jsonObject; });\n/* concated harmony reexport jsonMember */__webpack_require__.d(__webpack_exports__, \"jsonMember\", function() { return jsonMember; });\n/* concated harmony reexport jsonArrayMember */__webpack_require__.d(__webpack_exports__, \"jsonArrayMember\", function() { return jsonArrayMember; });\n/* concated harmony reexport jsonSetMember */__webpack_require__.d(__webpack_exports__, \"jsonSetMember\", function() { return jsonSetMember; });\n/* concated harmony reexport jsonMapMember */__webpack_require__.d(__webpack_exports__, \"jsonMapMember\", function() { return jsonMapMember; });\n/* concated harmony reexport toJson */__webpack_require__.d(__webpack_exports__, \"toJson\", function() { return toJson; });\n\n\n\n\n\n\n\n\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=typedjson.js.map \n\n//# sourceURL=webpack://shared/../node_modules/typedjson/js/typedjson.js?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar problem_1 = __webpack_require__(/*! ./models/math/problem */ \"./src/models/math/problem.ts\");\nexports.ProblemArchetype = problem_1.ProblemArchetype;\nexports.Problem = problem_1.Problem;\nexports.problemSerializer = problem_1.problemSerializer;\nvar template_1 = __webpack_require__(/*! ./models/math/template */ \"./src/models/math/template.ts\");\nexports.Template = template_1.Template;\nexports.templateSerializer = template_1.templateSerializer;\nvar mastery_1 = __webpack_require__(/*! ./models/users/mastery */ \"./src/models/users/mastery.ts\");\nexports.Mastery = mastery_1.Mastery;\nexports.masterySerializer = mastery_1.masterySerializer;\nvar users_1 = __webpack_require__(/*! ./models/users/users */ \"./src/models/users/users.ts\");\nexports.User = users_1.User;\nexports.UserType = users_1.UserType;\nexports.userSerializer = users_1.userSerializer;\nvar userCreation_1 = __webpack_require__(/*! ./models/users/userCreation */ \"./src/models/users/userCreation.ts\");\nexports.UserCreation = userCreation_1.UserCreation;\nexports.userCreationSerializer = userCreation_1.userCreationSerializer;\nvar auth_1 = __webpack_require__(/*! ./models/users/auth */ \"./src/models/users/auth.ts\");\nexports.AuthInfo = auth_1.AuthInfo;\nexports.authSerializer = auth_1.authSerializer;\nvar classroom_1 = __webpack_require__(/*! ./models/classroom/classroom */ \"./src/models/classroom/classroom.ts\");\nexports.Classroom = classroom_1.Classroom;\nexports.classroomSerializer = classroom_1.classroomSerializer;\n\n\n//# sourceURL=webpack://shared/./src/index.ts?");

/***/ }),

/***/ "./src/models/classroom/classroom.ts":
/*!*******************************************!*\
  !*** ./src/models/classroom/classroom.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__webpack_require__(/*! reflect-metadata */ \"../node_modules/reflect-metadata/Reflect.js\");\nconst typedjson_1 = __webpack_require__(/*! typedjson */ \"../node_modules/typedjson/js/typedjson.js\");\nlet Classroom = class Classroom {\n    constructor(name, passcode, teacherId, studentIds) {\n        this.name = name || '';\n        this.passcode = passcode || '';\n        this.teacherId = teacherId || '';\n        this.studentIds = studentIds || [];\n    }\n};\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", String)\n], Classroom.prototype, \"name\", void 0);\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", String)\n], Classroom.prototype, \"passcode\", void 0);\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", String)\n], Classroom.prototype, \"teacherId\", void 0);\n__decorate([\n    typedjson_1.jsonArrayMember(Array),\n    __metadata(\"design:type\", Array)\n], Classroom.prototype, \"studentIds\", void 0);\nClassroom = __decorate([\n    typedjson_1.jsonObject,\n    __metadata(\"design:paramtypes\", [String, String, String, Array])\n], Classroom);\nexports.Classroom = Classroom;\nexports.classroomSerializer = new typedjson_1.TypedJSON(Classroom);\n\n\n//# sourceURL=webpack://shared/./src/models/classroom/classroom.ts?");

/***/ }),

/***/ "./src/models/math/problem.ts":
/*!************************************!*\
  !*** ./src/models/math/problem.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__webpack_require__(/*! reflect-metadata */ \"../node_modules/reflect-metadata/Reflect.js\");\nconst typedjson_1 = __webpack_require__(/*! typedjson */ \"../node_modules/typedjson/js/typedjson.js\");\nvar ProblemArchetype;\n(function (ProblemArchetype) {\n    ProblemArchetype[\"ARITHMETIC\"] = \"arithmetic\";\n    ProblemArchetype[\"UNKNOWN\"] = \"unknown\";\n})(ProblemArchetype = exports.ProblemArchetype || (exports.ProblemArchetype = {}));\nlet Problem = class Problem {\n    constructor(problemArchetype, problemType, problem, solution, difficulty, seed) {\n        this.problemArchetype = problemArchetype || ProblemArchetype.UNKNOWN;\n        this.problemType = problemType || '';\n        this.problem = problem || '';\n        this.solution = solution || [''];\n        this.difficulty = difficulty || 0;\n        this.seed = seed || 0;\n    }\n};\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", String)\n], Problem.prototype, \"problemArchetype\", void 0);\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", String)\n], Problem.prototype, \"problemType\", void 0);\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", String)\n], Problem.prototype, \"problem\", void 0);\n__decorate([\n    typedjson_1.jsonArrayMember(String),\n    __metadata(\"design:type\", Array)\n], Problem.prototype, \"solution\", void 0);\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", Number)\n], Problem.prototype, \"difficulty\", void 0);\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", Number)\n], Problem.prototype, \"seed\", void 0);\nProblem = __decorate([\n    typedjson_1.jsonObject,\n    __metadata(\"design:paramtypes\", [String, String, String, Array, Number, Number])\n], Problem);\nexports.Problem = Problem;\nexports.problemSerializer = new typedjson_1.TypedJSON(Problem);\n\n\n//# sourceURL=webpack://shared/./src/models/math/problem.ts?");

/***/ }),

/***/ "./src/models/math/template.ts":
/*!*************************************!*\
  !*** ./src/models/math/template.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__webpack_require__(/*! reflect-metadata */ \"../node_modules/reflect-metadata/Reflect.js\");\nconst typedjson_1 = __webpack_require__(/*! typedjson */ \"../node_modules/typedjson/js/typedjson.js\");\nconst problem_1 = __webpack_require__(/*! ./problem */ \"./src/models/math/problem.ts\");\nlet Template = class Template {\n    constructor(problemArchetype, problemType, operators) {\n        this.problemArchetype = problemArchetype || problem_1.ProblemArchetype.UNKNOWN;\n        this.problemType = problemType || '';\n        this.operators = operators || [];\n    }\n};\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", String)\n], Template.prototype, \"problemArchetype\", void 0);\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", String)\n], Template.prototype, \"problemType\", void 0);\n__decorate([\n    typedjson_1.jsonArrayMember(String),\n    __metadata(\"design:type\", Array)\n], Template.prototype, \"operators\", void 0);\nTemplate = __decorate([\n    typedjson_1.jsonObject,\n    __metadata(\"design:paramtypes\", [String, String, Array])\n], Template);\nexports.Template = Template;\nexports.templateSerializer = new typedjson_1.TypedJSON(Template);\n\n\n//# sourceURL=webpack://shared/./src/models/math/template.ts?");

/***/ }),

/***/ "./src/models/users/auth.ts":
/*!**********************************!*\
  !*** ./src/models/users/auth.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__webpack_require__(/*! reflect-metadata */ \"../node_modules/reflect-metadata/Reflect.js\");\nconst typedjson_1 = __webpack_require__(/*! typedjson */ \"../node_modules/typedjson/js/typedjson.js\");\nlet AuthInfo = class AuthInfo {\n    constructor(userId, authToken, pushToken) {\n        this.userId = userId || '';\n        this.authToken = authToken || '';\n        this.pushToken = pushToken || '';\n    }\n};\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", String)\n], AuthInfo.prototype, \"userId\", void 0);\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", String)\n], AuthInfo.prototype, \"authToken\", void 0);\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", String)\n], AuthInfo.prototype, \"pushToken\", void 0);\nAuthInfo = __decorate([\n    typedjson_1.jsonObject,\n    __metadata(\"design:paramtypes\", [String, String, String])\n], AuthInfo);\nexports.AuthInfo = AuthInfo;\nexports.authSerializer = new typedjson_1.TypedJSON(AuthInfo);\n\n\n//# sourceURL=webpack://shared/./src/models/users/auth.ts?");

/***/ }),

/***/ "./src/models/users/mastery.ts":
/*!*************************************!*\
  !*** ./src/models/users/mastery.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__webpack_require__(/*! reflect-metadata */ \"../node_modules/reflect-metadata/Reflect.js\");\nconst typedjson_1 = __webpack_require__(/*! typedjson */ \"../node_modules/typedjson/js/typedjson.js\");\nlet Mastery = class Mastery {\n    constructor(problemType, difficulty, index, currentDifficultyPoints, totalPoints) {\n        this.problemType = problemType || '';\n        this.difficulty = difficulty || '';\n        this.index = index || 0;\n        this.currentDifficultyPoints = currentDifficultyPoints || 0;\n        this.totalPoints = totalPoints || 0;\n    }\n};\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", String)\n], Mastery.prototype, \"problemType\", void 0);\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", String)\n], Mastery.prototype, \"difficulty\", void 0);\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", Number)\n], Mastery.prototype, \"index\", void 0);\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", Number)\n], Mastery.prototype, \"currentDifficultyPoints\", void 0);\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", Number)\n], Mastery.prototype, \"totalPoints\", void 0);\nMastery = __decorate([\n    typedjson_1.jsonObject,\n    __metadata(\"design:paramtypes\", [String, String, Number, Number, Number])\n], Mastery);\nexports.Mastery = Mastery;\nexports.masterySerializer = new typedjson_1.TypedJSON(Mastery);\n\n\n//# sourceURL=webpack://shared/./src/models/users/mastery.ts?");

/***/ }),

/***/ "./src/models/users/userCreation.ts":
/*!******************************************!*\
  !*** ./src/models/users/userCreation.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__webpack_require__(/*! reflect-metadata */ \"../node_modules/reflect-metadata/Reflect.js\");\nconst typedjson_1 = __webpack_require__(/*! typedjson */ \"../node_modules/typedjson/js/typedjson.js\");\nconst users_1 = __webpack_require__(/*! ./users */ \"./src/models/users/users.ts\");\nlet UserCreation = class UserCreation {\n    constructor(authToken, pushToken, classroomName, classroomPasscode, user) {\n        this.authToken = authToken || '';\n        this.pushToken = pushToken || '';\n        this.classroomName = classroomName || '';\n        this.classroomPasscode = classroomPasscode || '';\n        this.user = user || new users_1.User();\n    }\n};\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", String)\n], UserCreation.prototype, \"authToken\", void 0);\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", String)\n], UserCreation.prototype, \"pushToken\", void 0);\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", String)\n], UserCreation.prototype, \"classroomName\", void 0);\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", String)\n], UserCreation.prototype, \"classroomPasscode\", void 0);\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", users_1.User)\n], UserCreation.prototype, \"user\", void 0);\nUserCreation = __decorate([\n    typedjson_1.jsonObject,\n    __metadata(\"design:paramtypes\", [String, String, String, String, users_1.User])\n], UserCreation);\nexports.UserCreation = UserCreation;\nexports.userCreationSerializer = new typedjson_1.TypedJSON(UserCreation);\n\n\n//# sourceURL=webpack://shared/./src/models/users/userCreation.ts?");

/***/ }),

/***/ "./src/models/users/users.ts":
/*!***********************************!*\
  !*** ./src/models/users/users.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__webpack_require__(/*! reflect-metadata */ \"../node_modules/reflect-metadata/Reflect.js\");\nconst typedjson_1 = __webpack_require__(/*! typedjson */ \"../node_modules/typedjson/js/typedjson.js\");\nvar UserType;\n(function (UserType) {\n    UserType[\"STUDENT\"] = \"student\";\n    UserType[\"TEACHER\"] = \"teacher\";\n    UserType[\"UNKNOWN\"] = \"unknown\";\n})(UserType = exports.UserType || (exports.UserType = {}));\nlet User = class User {\n    constructor(name, userType, virtualClassroomUid) {\n        this.name = name || '';\n        this.userType = userType || UserType.UNKNOWN;\n        this.virtualClassroomUid = virtualClassroomUid || '';\n    }\n};\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", String)\n], User.prototype, \"name\", void 0);\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", String)\n], User.prototype, \"userType\", void 0);\n__decorate([\n    typedjson_1.jsonMember,\n    __metadata(\"design:type\", String)\n], User.prototype, \"virtualClassroomUid\", void 0);\nUser = __decorate([\n    typedjson_1.jsonObject,\n    __metadata(\"design:paramtypes\", [String, String, String])\n], User);\nexports.User = User;\nexports.userSerializer = new typedjson_1.TypedJSON(User);\n\n\n//# sourceURL=webpack://shared/./src/models/users/users.ts?");

/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/index.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/index.ts */\"./src/index.ts\");\n\n\n//# sourceURL=webpack://shared/multi_./src/index.ts?");

/***/ })

/******/ });
});